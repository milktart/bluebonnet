<%
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  // Get today's date
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Calculate 19-month range: 3 months back, current month, 15 months forward
  const startMonth = new Date(today);
  startMonth.setMonth(today.getMonth() - 3);
  startMonth.setDate(1);

  const endMonth = new Date(today);
  endMonth.setMonth(today.getMonth() + 15);
  endMonth.setDate(1);

  // Helper function to get date key
  function getDateKey(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Helper function to parse DATEONLY strings
  const parseDateOnly = (dateStr) => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day, 0, 0, 0, 0);
    return date;
  };

  // Helper function to normalize a date to midnight (removes time component)
  const normalizeDate = (date) => {
    const normalized = new Date(date);
    normalized.setHours(0, 0, 0, 0);
    return normalized;
  };

  // Build dateToItems map from trips and standalone items
  const dateToItems = {}; // { dateKey: [{ type, data, startDate, endDate, durationDays }] }
  const tripItemsMap = {}; // { tripId: { flights: [], hotels: [], transportation: [], carRentals: [], events: [] } }

  // Add trips to dates
  const safeTrips = trips || [];
  safeTrips.forEach(trip => {
    if (!trip.departureDate || !trip.returnDate) return;

    const depDate = parseDateOnly(trip.departureDate);
    const retDate = parseDateOnly(trip.returnDate);

    const durationDays = Math.ceil((retDate - depDate) / (1000 * 60 * 60 * 24)) + 1;
    const startKey = getDateKey(depDate);
    if (!dateToItems[startKey]) dateToItems[startKey] = [];
    dateToItems[startKey].push({
      type: 'trip',
      data: trip,
      startDate: depDate,
      endDate: retDate,
      durationDays: durationDays
    });

    // Initialize trip items map for hierarchical display
    tripItemsMap[trip.id] = {
      flights: [],
      hotels: [],
      transportation: [],
      carRentals: [],
      events: []
    };

    // Add flights (nested inside trip, NOT to dateToItems)
    if (trip.flights) {
      trip.flights.forEach(flight => {
        if (!flight.departureDateTime) return;
        // Convert UTC departure time to origin airport's local timezone
        let startDate = new Date(flight.departureDateTime);
        if (flight.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        // Convert UTC arrival time to destination airport's local timezone
        let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
        if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const flightDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        tripItemsMap[trip.id].flights.push({ type: 'flight', data: flight, startDate, endDate, durationDays: flightDurationDays });
      });
    }

    // Add hotels (nested inside trip)
    if (trip.hotels) {
      trip.hotels.forEach(hotel => {
        if (!hotel.checkInDateTime) return;
        const startDate = new Date(hotel.checkInDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
        endDate.setHours(0, 0, 0, 0);
        const hotelDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        tripItemsMap[trip.id].hotels.push({ type: 'hotel', data: hotel, startDate, endDate, durationDays: hotelDurationDays });
      });
    }

    // Add transportation (nested inside trip)
    if (trip.transportation) {
      trip.transportation.forEach(trans => {
        if (!trans.departureDateTime) return;
        let startDate = new Date(trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const transDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        tripItemsMap[trip.id].transportation.push({ type: 'transportation', data: trans, startDate, endDate, durationDays: transDurationDays });
      });
    }

    // Add car rentals (nested inside trip)
    if (trip.carRentals) {
      trip.carRentals.forEach(carRental => {
        if (!carRental.pickupDateTime) return;
        const startDate = new Date(carRental.pickupDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
        endDate.setHours(0, 0, 0, 0);
        const carDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        tripItemsMap[trip.id].carRentals.push({ type: 'carRental', data: carRental, startDate, endDate, durationDays: carDurationDays });
      });
    }

    // Add events (nested inside trip)
    if (trip.events) {
      trip.events.forEach(event => {
        if (!event.startDateTime) return;
        let startDate = new Date(event.startDateTime);
        if (event.timezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(event.startDateTime, event.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }
        let endDate = new Date(event.endDateTime || event.startDateTime);
        if (event.timezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(event.endDateTime || event.startDateTime, event.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }
        const eventDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        tripItemsMap[trip.id].events.push({ type: 'event', data: event, startDate, endDate, durationDays: eventDurationDays });
      });
    }
  });

  // Add standalone flights
  const safeStandaloneFlights = standaloneFlights || [];
  safeStandaloneFlights.forEach(flight => {
    if (!flight.departureDateTime) return;
    // Convert UTC departure time to origin airport's local timezone
    let startDate = new Date(flight.departureDateTime);
    if (flight.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    // Convert UTC arrival time to destination airport's local timezone
    let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
    if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays });
  });

  // Add standalone hotels
  const safeStandaloneHotels = standaloneHotels || [];
  safeStandaloneHotels.forEach(hotel => {
    if (!hotel.checkInDateTime) return;
    const startDate = new Date(hotel.checkInDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays });
  });

  // Add standalone transportation
  const safeStandaloneTransportation = standaloneTransportation || [];
  safeStandaloneTransportation.forEach(trans => {
    if (!trans.departureDateTime) return;
    let startDate = new Date(trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays });
  });

  // Add standalone car rentals
  const safeStandaloneCarRentals = standaloneCarRentals || [];
  safeStandaloneCarRentals.forEach(carRental => {
    if (!carRental.pickupDateTime) return;
    const startDate = new Date(carRental.pickupDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays });
  });

  // Add standalone events
  const safeStandaloneEvents = standaloneEvents || [];
  safeStandaloneEvents.forEach(event => {
    if (!event.startDateTime) return;
    let startDate = new Date(event.startDateTime);
    if (event.timezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(event.startDateTime, event.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }
    let endDate = new Date(event.endDateTime || event.startDateTime);
    if (event.timezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(event.endDateTime || event.startDateTime, event.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays });
  });

  // Helper function to get transportation icon
  function getTransportationIcon(method) {
    const iconMap = {
      'train': 'train',
      'bus': 'directions_bus',
      'ferry': 'directions_boat',
      'shuttle': 'airport_shuttle',
      'taxi': 'hail',
      'rideshare': 'hail',
      'taxi/rideshare': 'hail',
      'subway': 'directions_subway',
      'metro': 'directions_subway',
      'subway/metro': 'directions_subway',
      'tram': 'tram',
      'funicular': 'funicular',
      'gondola': 'gondola_lift',
      'monorail': 'monorail',
      'other': 'directions_run'
    };
    return iconMap[method?.toLowerCase()] || 'transportation';
  }

  // Generate 19 months of data with continuous flow (28 columns per row)
  // Each month's days flow sequentially, with rows breaking every 28 days
  const months = [];
  let currentDate = new Date(startMonth);

  while (currentDate < endMonth) {
    const monthYear = { month: currentDate.getMonth(), year: currentDate.getFullYear() };
    const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();

    const days = [];
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(currentDate.getFullYear(), currentDate.getMonth(), day, 0, 0, 0, 0);
      const key = getDateKey(dateObj);
      days.push({
        day: day,
        dateKey: key,
        items: dateToItems[key] || [],
        isToday: key === getDateKey(today),
        isInvalid: false
      });
    }

    months.push({
      month: monthYear.month,
      year: monthYear.year,
      name: monthNames[monthYear.month],
      days: days
    });

    currentDate.setMonth(currentDate.getMonth() + 1);
  }

  // Now reflow the days into 28-column rows (4 weeks × 7 days)
  // Each row contains exactly 28 days, aligned to Monday-Sunday weeks
  // Weeks are always Monday-Sunday, so add buffer days to align properly
  const reflowedMonths = [];
  let allDays = [];

  // Flatten all days from all months into a single array
  months.forEach(month => {
    month.days.forEach(day => {
      allDays.push({ ...day, originalMonth: month.month, originalYear: month.year });
    });
  });

  // Add buffer days at the start to align the first day to a Monday
  // Find what day of the week the first day is (0 = Sunday, 1 = Monday, etc.)
  const firstDate = new Date(allDays[0].dateKey.split('-').map(Number)[0], allDays[0].dateKey.split('-').map(Number)[1] - 1, allDays[0].dateKey.split('-').map(Number)[2]);
  const firstDayOfWeek = firstDate.getDay(); // 0 = Sunday, 1 = Monday, etc.

  // Calculate how many days before this date we need to add to align to Monday
  const daysBeforeMonday = (firstDayOfWeek + 6) % 7; // Convert Sunday=0 to Sunday=6, then -1 for days before Monday

  // Add buffer days from the previous month if needed
  if (daysBeforeMonday > 0) {
    let bufferDate = new Date(firstDate);
    bufferDate.setDate(bufferDate.getDate() - daysBeforeMonday);
    for (let i = 0; i < daysBeforeMonday; i++) {
      const key = getDateKey(bufferDate);
      allDays.unshift({
        dateKey: key,
        day: bufferDate.getDate(),
        items: dateToItems[key] || [],
        isToday: key === getDateKey(today),
        isInvalid: false,
        isBufferDay: true,
        originalMonth: bufferDate.getMonth(),
        originalYear: bufferDate.getFullYear()
      });
      bufferDate.setDate(bufferDate.getDate() + 1);
    }
  }

  // Pre-calculate global item row assignments based on overlaps
  const globalItemRowAssignments = {};
  const globalRowOccupancy = []; // Array of arrays tracking which items are in each row
  const processedItemIds = new Set(); // Track which items we've already processed

  // Sort all items by start date first
  const allItems = [];
  Object.keys(dateToItems).forEach(dateKey => {
    dateToItems[dateKey].forEach(item => {
      allItems.push(item);
    });
  });
  allItems.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

  // Remove duplicates (same item ID can appear multiple times in dateToItems)
  const uniqueItems = [];
  const seenIds = new Set();
  allItems.forEach(item => {
    if (!seenIds.has(item.data.id)) {
      seenIds.add(item.data.id);
      uniqueItems.push(item);
    }
  });

  // Assign each unique item to a global row number
  uniqueItems.forEach(item => {
    const itemId = item.data.id;

    // Normalize item dates for comparison
    const itemStart = normalizeDate(item.startDate).getTime();
    const itemEnd = normalizeDate(item.endDate).getTime();

    let assignedRow = -1;

    // Find first row where item doesn't overlap with anything
    for (let rowIdx = 0; rowIdx < globalRowOccupancy.length; rowIdx++) {
      let canFitInRow = true;
      // Check if item overlaps with any item in this row
      for (const otherItem of globalRowOccupancy[rowIdx]) {
        const otherStart = normalizeDate(otherItem.startDate).getTime();
        const otherEnd = normalizeDate(otherItem.endDate).getTime();
        // Items overlap if they share any days: NOT (end < otherStart OR start > otherEnd)
        const overlaps = !(itemEnd < otherStart || itemStart > otherEnd);

        if (overlaps) {
          canFitInRow = false;
          break;
        }
      }
      if (canFitInRow) {
        assignedRow = rowIdx;
        globalRowOccupancy[rowIdx].push(item);
        break;
      }
    }

    // Create new row if needed
    if (assignedRow === -1) {
      assignedRow = globalRowOccupancy.length;
      globalRowOccupancy.push([item]);
    }

    globalItemRowAssignments[itemId] = assignedRow;
  });


  // Group days into chunks of 30, creating month rows
  // Each row is exactly 30 days (approximately 4 weeks + buffer)
  let rowStartIndex = 0;
  let monthIndex = 0;

  while (rowStartIndex < allDays.length && monthIndex < months.length) {
    const monthRowDays = [];

    // Collect exactly 30 days for this row
    for (let i = 0; i < 30 && rowStartIndex < allDays.length; i++) {
      monthRowDays.push(allDays[rowStartIndex]);
      rowStartIndex++;
    }

    reflowedMonths.push({
      month: months[monthIndex].month,
      year: months[monthIndex].year,
      name: months[monthIndex].name,
      days: monthRowDays
    });

    monthIndex++;
  }

%>

<div class="calendar-row-view h-full flex flex-col">
  <!-- Calendar grid - scrollable -->
  <div class="flex-1 overflow-auto">
    <div class="row-calendar-grid">
      <!-- Month rows -->
      <% reflowedMonths.forEach((monthData) => { %>
        <%
          // Calculate the number of item rows needed for this row
          // Get the date range for this row
          const heightRowStartDate = monthData.days.length > 0
            ? new Date(monthData.days[0].dateKey.split('-').map(Number)[0],
                       monthData.days[0].dateKey.split('-').map(Number)[1] - 1,
                       monthData.days[0].dateKey.split('-').map(Number)[2])
            : new Date();

          const heightRowEndDate = monthData.days.length > 0
            ? new Date(monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[0],
                       monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[1] - 1,
                       monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[2])
            : new Date();

          // Calculate month height based on max global row number that appears in this row
          let maxRowInMonth = -1;
          let maxNestedItemsInRow = 0;
          const itemsInThisRow = [];
          const seenItemIds = new Set();

          // Find all items that overlap with this row and get their global row assignments
          // IMPORTANT: Items are stored in dateToItems only at their START DATE
          // So we need to check ALL dateToItems keys, not just ones within the month row dates
          Object.keys(dateToItems).forEach(dateKey => {
            const items = dateToItems[dateKey] || [];
            items.forEach(item => {
              // Check if item overlaps with this row
              // Item overlaps if: item.end >= rowStart AND item.start <= rowEnd
              if (normalizeDate(item.endDate).getTime() >= normalizeDate(heightRowStartDate).getTime() && normalizeDate(item.startDate).getTime() <= normalizeDate(heightRowEndDate).getTime()) {
                const globalRow = globalItemRowAssignments[item.data.id];
                if (!seenItemIds.has(item.data.id)) {
                  seenItemIds.add(item.data.id);
                  itemsInThisRow.push({ id: item.data.id, globalRow });
                  if (globalRow > maxRowInMonth) {
                    maxRowInMonth = globalRow;
                  }

                  // For trips, calculate how many nested items they have to determine their height
                  if (item.type === 'trip' && tripItemsMap[item.data.id]) {
                    const nestedItems = tripItemsMap[item.data.id];
                    const totalNestedItems = nestedItems.flights.length + nestedItems.hotels.length + nestedItems.transportation.length + nestedItems.carRentals.length + nestedItems.events.length;
                    // Trip takes up 1.5rem for header + (totalNestedItems * 1.75rem) for nested items + margins
                    const tripRowHeight = 1.5 + (totalNestedItems * 1.75) + 0.25;
                    // Convert to number of 1.75rem rows
                    const tripRowsNeeded = Math.ceil(tripRowHeight / 1.75);
                    if (tripRowsNeeded > 1) {
                      maxNestedItemsInRow = Math.max(maxNestedItemsInRow, tripRowsNeeded - 1);
                    }
                  }
                }
              }
            });
          });


          // Calculate height: we need room for all rows up to maxRowInMonth plus extra space for nested trip items
          const monthHeight = Math.max(2, 1.2 + (maxRowInMonth + 1) * 1.75 + maxNestedItemsInRow * 1.75);
        %>
        <div class="month-row-wrapper" style="min-height: <%= monthHeight %>rem;">
          <!-- Month label -->
          <div class="month-row-label">
            <div class="month-name"><%= monthData.name.substring(0, 3) %></div>
            <div class="year"><%= monthData.year %></div>
          </div>

          <!-- Days grid with items -->
          <div class="days-row-grid">
            <!-- Multi-day items layer -->
            <div class="row-multi-day-layer">
              <%
                // Collect items that overlap with this row's date range
                const monthItems = [];
                const rowItemIds = new Set();

                // Get the date range for this row
                const rowStartDate = monthData.days.length > 0
                  ? new Date(monthData.days[0].dateKey.split('-').map(Number)[0],
                             monthData.days[0].dateKey.split('-').map(Number)[1] - 1,
                             monthData.days[0].dateKey.split('-').map(Number)[2])
                  : new Date();

                const rowEndDate = monthData.days.length > 0
                  ? new Date(monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[0],
                             monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[1] - 1,
                             monthData.days[monthData.days.length - 1].dateKey.split('-').map(Number)[2])
                  : new Date();

                // Iterate through all dateToItems to find items that overlap with this row
                Object.keys(dateToItems).forEach(dateKey => {
                  const items = dateToItems[dateKey] || [];
                  items.forEach(item => {
                    const itemId = item.data.id;

                    // Check if item overlaps with this row and hasn't been added yet
                    if (normalizeDate(item.endDate).getTime() >= normalizeDate(rowStartDate).getTime() && normalizeDate(item.startDate).getTime() <= normalizeDate(rowEndDate).getTime() && !rowItemIds.has(itemId)) {
                      rowItemIds.add(itemId);
                      monthItems.push({ item, itemId });
                    }
                  });
                });

                // Sort items by start date ascending
                monthItems.sort((a, b) => {
                  const dateA = a.item.startDate;
                  const dateB = b.item.startDate;
                  return dateA.getTime() - dateB.getTime();
                });

                // Use pre-calculated global row assignments and calculate column positions
                monthItems.forEach((itemData) => {
                  // Find the position of this item in the row's day array
                  const itemStartDate = itemData.item.startDate;
                  const itemEndDate = itemData.item.endDate;
                  let startCol = -1;
                  let endCol = -1;

                  // Find the first day this item appears in this row
                  for (let i = 0; i < monthData.days.length; i++) {
                    const dayDate = new Date(monthData.days[i].dateKey.split('-').map(Number)[0],
                                            monthData.days[i].dateKey.split('-').map(Number)[1] - 1,
                                            monthData.days[i].dateKey.split('-').map(Number)[2]);

                    if (normalizeDate(dayDate).getTime() >= normalizeDate(itemStartDate).getTime()) {
                      startCol = i;
                      break;
                    }
                  }

                  // Find the last day this item appears in this row
                  for (let i = monthData.days.length - 1; i >= 0; i--) {
                    const dayDate = new Date(monthData.days[i].dateKey.split('-').map(Number)[0],
                                            monthData.days[i].dateKey.split('-').map(Number)[1] - 1,
                                            monthData.days[i].dateKey.split('-').map(Number)[2]);

                    if (normalizeDate(dayDate).getTime() <= normalizeDate(itemEndDate).getTime()) {
                      endCol = i;
                      break;
                    }
                  }

                  // Skip if item doesn't actually appear in this row (shouldn't happen but be safe)
                  if (startCol === -1 || endCol === -1) {
                    return;
                  }

                  const daysSpanned = endCol - startCol + 1;
                  const assignedRow = globalItemRowAssignments[itemData.itemId];

                  // Store calculated values for rendering
                  itemData.rowInMonth = (assignedRow !== undefined) ? assignedRow : 0;
                  itemData.daysSpanned = daysSpanned;
                  itemData.startCol = startCol;

                });
              %>
              <% monthItems.forEach((itemData) => { %>
                <%
                  const { item, itemId, rowInMonth, daysSpanned, startCol } = itemData;
                  const itemType = item.type;
                  const itemColor = getItemHexColor(itemType);
                %>
                <% if (itemType === 'trip') { %>
                  <%
                    const tripColor = item.data.purpose === 'business' ? getItemHexColor('business') : getItemHexColor('trip');
                    const nestedItems = tripItemsMap[itemId] || { flights: [], hotels: [], transportation: [], carRentals: [], events: [] };
                    const totalNestedItems = nestedItems.flights.length + nestedItems.hotels.length + nestedItems.transportation.length + nestedItems.carRentals.length + nestedItems.events.length;
                    // Calculate container height: base height + nested items rows
                    const tripContainerHeight = 1.5 + (totalNestedItems * 1.75);
                  %>
                  <!-- Trip bar container with nested items positioned inside -->
                  <div class="trip-container-wrapper" data-item-id="<%= itemId %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; --height: <%= tripContainerHeight %>rem;">
                    <!-- Trip bar header - spans full width -->
                    <div class="row-multi-day-bar calendar-item trip-bar <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %>" data-item-id="<%= itemId %>" data-item-type="trip" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="background-color: <%= tripColor %>33; color: <%= tripColor %>;">
                      <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= tripColor %>;">luggage</span>
                      <span class="truncate"><%= item.data.name %></span>
                    </div>

                    <!-- Nested items inside trip container -->
                    <div class="nested-items-container">
                      <% nestedItems.flights.forEach((flight, idx) => { %>
                        <div class="nested-item nested-flight" data-item-id="<%= flight.data.id %>" data-item-type="flight" style="background-color: <%= getItemHexColor('flight') %>33; color: <%= getItemHexColor('flight') %>;">
                          <span class="material-symbols-outlined" style="font-size: 12px; flex-shrink: 0; color: <%= getItemHexColor('flight') %>;">flight_takeoff</span>
                          <span class="truncate">
                            <%= flight.data.origin ? flight.data.origin.substring(0, 3).toUpperCase() : '' %>
                            →
                            <%= flight.data.destination ? flight.data.destination.substring(0, 3).toUpperCase() : '' %>
                          </span>
                        </div>
                      <% }) %>
                      <% nestedItems.hotels.forEach((hotel, idx) => { %>
                        <div class="nested-item nested-hotel" data-item-id="<%= hotel.data.id %>" data-item-type="hotel" style="background-color: <%= getItemHexColor('hotel') %>33; color: <%= getItemHexColor('hotel') %>;">
                          <span class="material-symbols-outlined" style="font-size: 12px; flex-shrink: 0; color: <%= getItemHexColor('hotel') %>;">hotel</span>
                          <span class="truncate"><%= hotel.data.hotelName %></span>
                        </div>
                      <% }) %>
                      <% nestedItems.transportation.forEach((trans, idx) => { %>
                        <div class="nested-item nested-transportation" data-item-id="<%= trans.data.id %>" data-item-type="transportation" style="background-color: <%= getItemHexColor('transportation') %>33; color: <%= getItemHexColor('transportation') %>;">
                          <span class="material-symbols-outlined" style="font-size: 12px; flex-shrink: 0; color: <%= getItemHexColor('transportation') %>;"><%= getTransportationIcon(trans.data.method) %></span>
                          <span class="truncate"><%= trans.data.origin %> → <%= trans.data.destination %></span>
                        </div>
                      <% }) %>
                      <% nestedItems.carRentals.forEach((carRental, idx) => { %>
                        <div class="nested-item nested-car-rental" data-item-id="<%= carRental.data.id %>" data-item-type="carRental" style="background-color: <%= getItemHexColor('carRental') %>33; color: <%= getItemHexColor('carRental') %>;">
                          <span class="material-symbols-outlined" style="font-size: 12px; flex-shrink: 0; color: <%= getItemHexColor('carRental') %>;">directions_car</span>
                          <span class="truncate"><%= carRental.data.company %></span>
                        </div>
                      <% }) %>
                      <% nestedItems.events.forEach((event, idx) => { %>
                        <div class="nested-item nested-event <% if (!event.data.isConfirmed) { %>calendar-item-tentative<% } %>" data-item-id="<%= event.data.id %>" data-item-type="event" style="background-color: <%= getItemHexColor('event') %>33; color: <%= getItemHexColor('event') %>;">
                          <span class="material-symbols-outlined" style="font-size: 12px; flex-shrink: 0; color: <%= getItemHexColor('event') %>;">event</span>
                          <span class="truncate"><%= event.data.name %></span>
                        </div>
                      <% }) %>
                    </div>
                  </div>
                <% } else if (itemType === 'flight') { %>
                  <%
                    const originCode = item.data.origin ? item.data.origin.substring(0, 3).toUpperCase() : '';
                    const destCode = item.data.destination ? item.data.destination.substring(0, 3).toUpperCase() : '';
                  %>
                  <div class="row-multi-day-bar flight-bar-row calendar-item" data-item-id="<%= itemId %>" data-item-type="flight" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <div class="flight-codes-row">
                      <div><%= originCode %></div>
                      <div><%= destCode %></div>
                    </div>
                  </div>
                <% } else if (itemType === 'hotel') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="hotel" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">hotel</span>
                    <span class="truncate"><%= item.data.hotelName %></span>
                  </div>
                <% } else if (itemType === 'event') { %>
                  <div class="row-multi-day-bar <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %> calendar-item" data-item-id="<%= itemId %>" data-item-type="event" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">event</span>
                    <span class="truncate"><%= item.data.name %></span>
                  </div>
                <% } else if (itemType === 'transportation') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="transportation" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;"><%= getTransportationIcon(item.data.method) %></span>
                    <span class="truncate"><%= item.data.origin %> → <%= item.data.destination %></span>
                  </div>
                <% } else if (itemType === 'carRental') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="carRental" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">directions_car</span>
                    <span class="truncate"><%= item.data.company %></span>
                  </div>
                <% } %>
              <% }) %>
            </div>

            <!-- Day cells -->
            <% monthData.days.forEach((dayData, dayIdx) => { %>
              <%
                const hasItems = dayData.items && dayData.items.length > 0;
                // Weekend detection based on actual day of week from the date
                const dayDate = new Date(dayData.dateKey.split('-').map(Number)[0],
                                        dayData.dateKey.split('-').map(Number)[1] - 1,
                                        dayData.dateKey.split('-').map(Number)[2]);
                // getDay: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
                // We want: Saturday (6) and Sunday (0) to be weekends
                const dayOfWeek = dayDate.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // Sunday and Saturday
                const isBufferDay = dayData.isBufferDay || dayData.isInvalid;
              %>
              <div class="row-day-cell <% if (isBufferDay) { %>buffer-day<% } %> <% if (dayData.isToday) { %>today<% } %> <% if (hasItems) { %>has-items<% } %> <% if (isWeekend) { %>weekend<% } %>" id="date-<%= dayData.dateKey %>" data-date="<%= dayData.dateKey %>">
                <% if (!isBufferDay) { %>
                  <div class="day-number"><%= dayData.day %></div>
                <% } %>
              </div>
            <% }) %>
          </div>
        </div>
      <% }) %>
    </div>
  </div>
</div>

<style>
  .calendar-row-view {
    display: flex;
    flex-direction: column;
  }

  .row-calendar-grid {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .month-row-wrapper {
    display: flex;
    gap: 0;
    align-items: stretch;
    border-left: 2px solid #e5e7eb;
    position: relative;
  }

  .month-row-label {
    width: 50px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: #6b7280;
    background: #f9fafb;
    padding: 0.5rem 0.25rem;
    flex-shrink: 0;
    text-align: center;
    border-right: 2px solid #e5e7eb;
  }

  .month-row-label .month-name {
    font-weight: 700;
  }

  .month-row-label .year {
    font-size: 0.65rem;
    color: #9ca3af;
  }

  .days-row-grid {
    display: grid;
    grid-template-columns: repeat(30, minmax(24px, 1fr));
    gap: 0;
    flex: 1;
    position: relative;
  }

  .row-multi-day-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  .row-multi-day-bar {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.5rem;
    pointer-events: auto;
    top: calc(1.2rem + var(--row-in-month) * 1.75rem);
    left: calc(var(--day-idx) * calc(100% / 30) + 1px);
    width: calc(var(--span) * calc(100% / 30) - 2px);
  }

  /* Calendar item styling */
  .calendar-item {
    cursor: pointer;
  }

  .calendar-item:hover {
    opacity: 0.85;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  /* Flight bar row view - centered two-line airport codes */
  .row-multi-day-bar.flight-bar-row {
    padding: 0;
    gap: 0;
    justify-content: center;
  }

  .flight-codes-row {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    gap: 0;
    font-weight: bold;
    font-size: 0.65rem;
    line-height: 1;
  }

  .calendar-item-tentative::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.1) 2px,
      rgba(0, 0, 0, 0.1) 4px
    );
    pointer-events: none;
    border-radius: 0.25rem;
  }

  .row-day-cell {
    border-right: 1px solid rgba(229, 231, 235, 0.4);
    border-bottom: none;
    padding: 0;
    overflow: visible;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    min-height: 32px;
    background: white;
    transition: background-color 0.2s;
  }

  .row-day-cell:hover {
    background-color: #f9fafb;
  }

  .row-day-cell.weekend {
    background-color: #fafafa;
  }

  .row-day-cell.weekend:hover {
    background-color: #f5f5f5;
  }

  .row-day-cell.today {
    background-color: #eff6ff;
    border-right-color: #3b82f6;
  }

  .row-day-cell.today .day-number {
    color: #3b82f6;
    font-weight: 600;
  }

  .row-day-cell.invalid-day {
    background-color: #f3f4f6;
    cursor: not-allowed;
    border-right-color: rgba(209, 213, 219, 0.4);
  }

  .row-day-cell.invalid-day:hover {
    background-color: #f3f4f6;
  }

  .day-number {
    font-size: 0.7rem;
    font-weight: 500;
    color: #374151;
    padding: 0.25rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 5;
  }

  .row-day-cell.has-items {
    padding-top: 0;
  }

  /* Trip container wrapper - positioned absolutely on the calendar grid */
  .trip-container-wrapper {
    position: absolute;
    left: calc(var(--day-idx) * calc(100% / 30) + 1px);
    width: calc(var(--span) * calc(100% / 30) - 2px);
    top: calc(1.2rem + var(--row-in-month) * 1.75rem);
    height: var(--height);
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  /* Trip bar header - first item in trip container */
  .trip-bar {
    position: static !important;
    top: auto !important;
    left: auto !important;
    width: 100% !important;
    height: 1.5rem !important;
    margin: 0 !important;
    padding: 0.25rem 0.5rem !important;
    flex-shrink: 0;
  }

  /* Nested items container - vertical flex layout for items stacked within trip */
  .nested-items-container {
    position: relative;
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    padding: 0.25rem;
    flex: 1;
    overflow: hidden;
  }

  /* Individual nested item styling - regular flow within container */
  .nested-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.7rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.25rem;
    position: relative;
    flex-shrink: 0;
    cursor: pointer;
    border-left: 2px solid currentColor;
  }

  .nested-item:hover {
    opacity: 0.85;
    box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.1);
  }

  .nested-item .material-symbols-outlined {
    font-size: 10px;
    flex-shrink: 0;
  }

  .nested-item .truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    min-width: 0;
  }

  /* Tentative nested item styling */
  .nested-item.calendar-item-tentative::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.05) 2px,
      rgba(0, 0, 0, 0.05) 4px
    );
    pointer-events: none;
    border-radius: 0.25rem;
  }
</style>

<script>
  function scrollYearViewToday() {
    const todayCell = document.querySelector('.row-day-cell.today');
    if (todayCell) {
      todayCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  window.scrollYearViewToday = scrollYearViewToday;
</script>
