<%
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; // Monday start

  function getDateKey(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  function getMondayColumn(date) {
    // Returns 0-6 where 0 = Monday, 6 = Sunday
    const dayOfWeek = date.getDay();
    return dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  }

  // Create today's date in local timezone
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Helper function to parse DATEONLY strings (YYYY-MM-DD format)
  const parseDateOnly = (dateStr) => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day, 0, 0, 0, 0);
    return date;
  };

  // Calculate date range: show 13 months total
  // Last month + current month + next 11 months
  const startDate = new Date(today);
  startDate.setMonth(today.getMonth() - 1); // 1 month back
  startDate.setDate(1);

  const endDate = new Date(today);
  endDate.setMonth(today.getMonth() + 11); // 11 months forward
  endDate.setDate(0); // Last day of month

  // Build a flat list of all dates in range with their items
  const dateToItems = {}; // { dateKey: [{ type, data }] }
  const allDates = []; // All dates in order for continuous layout

  // Generate all dates in range
  let currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const key = getDateKey(currentDate);
    dateToItems[key] = [];
    allDates.push(new Date(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Add trips to dates
  const safeTrips = trips || [];
  safeTrips.forEach(trip => {
    if (!trip.departureDate || !trip.returnDate) return;

    const depDate = parseDateOnly(trip.departureDate);
    const retDate = parseDateOnly(trip.returnDate);

    // For multi-day trips, only add to start date with duration info
    const durationDays = Math.ceil((retDate - depDate) / (1000 * 60 * 60 * 24)) + 1;
    const startKey = getDateKey(depDate);
    if (dateToItems[startKey]) {
      dateToItems[startKey].push({
        type: 'trip',
        data: trip,
        startDate: depDate,
        endDate: retDate,
        durationDays: durationDays
      });
    }

    // Add items within the trip (flights, hotels, transportation, car rentals, events)
    if (trip.flights) {
      trip.flights.forEach(flight => {
        if (!flight.departureDateTime) return;
        // Convert UTC departure time to origin airport's local timezone
        let startDate = new Date(flight.departureDateTime);
        if (flight.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        // Convert UTC arrival time to destination airport's local timezone
        let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
        if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const flightDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays: flightDurationDays });
        }
      });
    }

    if (trip.hotels) {
      trip.hotels.forEach(hotel => {
        if (!hotel.checkInDateTime) return;
        const startDate = new Date(hotel.checkInDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
        endDate.setHours(0, 0, 0, 0);
        const hotelDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays: hotelDurationDays });
        }
      });
    }

    if (trip.transportation) {
      trip.transportation.forEach(trans => {
        if (!trans.departureDateTime) return;
        // Convert UTC departure time to departure city's timezone for calendar positioning
        let startDate = new Date(trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const transDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays: transDurationDays });
        }
      });
    }

    if (trip.carRentals) {
      trip.carRentals.forEach(carRental => {
        if (!carRental.pickupDateTime) return;
        const startDate = new Date(carRental.pickupDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
        endDate.setHours(0, 0, 0, 0);
        const carDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays: carDurationDays });
        }
      });
    }

    if (trip.events) {
      trip.events.forEach(event => {
        if (!event.startDateTime) return;
        // Convert event start time to event's timezone for calendar positioning
        let startDate = new Date(event.startDateTime);
        if (event.timezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(event.startDateTime, event.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        // Convert event end time to event's timezone for calendar positioning
        let endDate = new Date(event.endDateTime || event.startDateTime);
        if (event.timezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(event.endDateTime || event.startDateTime, event.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const eventDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays: eventDurationDays });
        }
      });
    }
  });

  // Add standalone items (flights, hotels, transportation, events not part of trips)
  const safeStandaloneFlights = standaloneFlights || [];
  const safeStandaloneHotels = standaloneHotels || [];
  const safeStandaloneTransportation = standaloneTransportation || [];
  const safeStandaloneCarRentals = standaloneCarRentals || [];
  const safeStandaloneEvents = standaloneEvents || [];

  // Add standalone flights
  safeStandaloneFlights.forEach(flight => {
    if (!flight.departureDateTime) return;
    // Convert UTC departure time to origin airport's local timezone
    let startDate = new Date(flight.departureDateTime);
    if (flight.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    // Convert UTC arrival time to destination airport's local timezone
    let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
    if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays });
    }
  });

  // Add standalone hotels
  safeStandaloneHotels.forEach(hotel => {
    if (!hotel.checkInDateTime) return;
    const startDate = new Date(hotel.checkInDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays });
    }
  });

  // Add standalone transportation
  safeStandaloneTransportation.forEach(trans => {
    if (!trans.departureDateTime) return;
    // Convert UTC departure time to departure city's timezone for calendar positioning
    let startDate = new Date(trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays });
    }
  });

  // Add standalone car rentals
  safeStandaloneCarRentals.forEach(carRental => {
    if (!carRental.pickupDateTime) return;
    const startDate = new Date(carRental.pickupDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays });
    }
  });

  // Add standalone events
  safeStandaloneEvents.forEach(event => {
    if (!event.startDateTime) return;
    // Convert event start time to event's timezone for calendar positioning
    let startDate = new Date(event.startDateTime);
    if (event.timezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(event.startDateTime, event.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    // Convert event end time to event's timezone for calendar positioning
    let endDate = new Date(event.endDateTime || event.startDateTime);
    if (event.timezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(event.endDateTime || event.startDateTime, event.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays });
    }
  });

  // Function to get transportation icon based on method
  function getTransportationIcon(method) {
    const iconMap = {
      'train': 'train',
      'bus': 'directions_bus',
      'ferry': 'directions_boat',
      'shuttle': 'airport_shuttle',
      'taxi': 'hail',
      'rideshare': 'hail',
      'taxi/rideshare': 'hail',
      'subway': 'directions_subway',
      'metro': 'directions_subway',
      'subway/metro': 'directions_subway',
      'tram': 'tram',
      'funicular': 'funicular',
      'gondola': 'gondola_lift',
      'monorail': 'monorail',
      'other': 'directions_run'
    };
    return iconMap[method?.toLowerCase()] || 'transportation';
  }

  // Helper function to check if an item spans multiple days
  function isMultiDay(item) {
    return item.durationDays > 1;
  }

  // Helper function to find the grid column index for a date
  function getDateGridColumn(dateKey, weeks, dayNames) {
    for (let weekIdx = 0; weekIdx < weeks.length; weekIdx++) {
      for (let dayIdx = 0; dayIdx < weeks[weekIdx].length; dayIdx++) {
        if (getDateKey(weeks[weekIdx][dayIdx]) === dateKey) {
          return { weekIdx, dayIdx };
        }
      }
    }
    return null;
  }

  // Generate calendar weeks (Monday-Sunday)
  const weeks = [];
  let weekDates = [];

  // Start with the Monday of the first week
  let calendarStart = new Date(startDate);
  const mondayCol = getMondayColumn(calendarStart);
  calendarStart.setDate(calendarStart.getDate() - mondayCol);

  currentDate = new Date(calendarStart);
  while (currentDate <= endDate) {
    weekDates.push(new Date(currentDate));

    if (weekDates.length === 7) {
      weeks.push(weekDates);
      weekDates = [];
    }

    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Add remaining dates as final week if needed
  if (weekDates.length > 0) {
    weeks.push(weekDates);
  }

  // Track which multi-day items have been rendered to avoid duplicates
  const renderedMultiDayItems = new Set();

%>

<div class="calendar-sidebar h-full flex flex-col">
  <!-- View toggle header -->
  <div class="sticky top-0 z-20 bg-white border-b border-gray-200 px-4 py-2 flex items-center justify-between">
    <h3 class="text-sm font-semibold text-gray-700">Calendar</h3>
    <button id="calendar-view-toggle" onclick="toggleCalendarView()" class="p-1.5 rounded hover:bg-gray-100 transition-colors" title="Toggle calendar view">
      <span class="material-symbols-outlined text-gray-600" id="toggle-icon" style="font-size: 20px;">view_week</span>
    </button>
  </div>

  <div class="flex flex-1 overflow-hidden">
    <!-- Week view (default) -->
    <div id="calendar-view-week" class="calendar-view active flex-1 overflow-y-auto" style="display: block;">
      <div id="calendar-scroll">
      <div class="p-4">
        <!-- Day header -->
        <div class="sticky top-0 z-10 pb-2 mb-0">
          <div class="grid" style="grid-template-columns: 35px repeat(7, 1fr); gap: 0rem;">
            <div class="text-center text-xs font-semibold text-gray-500 p-2"></div>
            <% dayNames.forEach(day => { %>
              <div class="text-center text-xs font-semibold text-gray-600 p-2">
                <%= day %>
              </div>
            <% }) %>
          </div>
        </div>

        <!-- Continuous calendar weeks -->
        <% weeks.forEach((week, weekIdx) => { %>
          <%
            // Check if this week contains the 1st of any month
            let monthLabelForWeek = null;
            week.forEach(day => {
              if (day.getDate() === 1) {
                monthLabelForWeek = {
                  month: monthNames[day.getMonth()].substring(0, 3),
                  year: String(day.getFullYear()).substring(2)
                };
              }
            });
          %>
          <!-- Week row wrapper -->
          <div class="calendar-week-wrapper" data-week="<%= weekIdx %>">
            <!-- Floating items layer (positioned absolutely) -->
            <div class="calendar-multi-day-layer">
              <%
                // Collect all items for this week organized by day and row
                const weekItems = [];

                // First, collect items starting in this week
                week.forEach((date, dayIdx) => {
                  const dateKey = getDateKey(date);
                  const items = dateToItems[dateKey] || [];

                  items.forEach(item => {
                    const itemId = item.data.id;
                    const isFirstDay = dateKey === getDateKey(item.startDate);
                    if (isFirstDay && !renderedMultiDayItems.has(itemId)) {
                      renderedMultiDayItems.add(itemId);
                      weekItems.push({ item, dayIdx, itemId, isContinuation: false });
                    }
                  });
                });

                // Check for items from previous weeks that continue into this week
                if (weekIdx > 0) {
                  const weekStartDate = week[0];
                  const continuationItemsThisWeek = new Set();

                  // Look at ALL items added to dates in previous weeks
                  const allPreviousItems = new Set();
                  for (let prevWeekIdx = 0; prevWeekIdx < weekIdx; prevWeekIdx++) {
                    weeks[prevWeekIdx].forEach((date) => {
                      const dateKey = getDateKey(date);
                      const items = dateToItems[dateKey] || [];
                      items.forEach(item => {
                        allPreviousItems.add(item.data.id);
                      });
                    });
                  }

                  // Check each previous item to see if it continues into this week
                  allPreviousItems.forEach(itemId => {
                    // Find the item in dateToItems
                    let foundItem = null;
                    for (let prevWeekIdx = 0; prevWeekIdx < weekIdx; prevWeekIdx++) {
                      weeks[prevWeekIdx].forEach((date) => {
                        const dateKey = getDateKey(date);
                        const items = dateToItems[dateKey] || [];
                        items.forEach(item => {
                          if (item.data.id === itemId && !foundItem) {
                            foundItem = item;
                          }
                        });
                      });
                    }

                    // If item ends on or after this week's start, it's a continuation
                    if (foundItem && foundItem.endDate >= weekStartDate && !continuationItemsThisWeek.has(itemId)) {
                      continuationItemsThisWeek.add(itemId);
                      weekItems.push({ item: foundItem, dayIdx: 0, itemId, isContinuation: true });
                    }
                  });
                }

                // Sort items by start date ascending (earliest first), with stable sort for items on same day
                weekItems.sort((a, b) => {
                  const dateA = a.item.startDate;
                  const dateB = b.item.startDate;
                  if (dateA.getTime() === dateB.getTime()) {
                    // For items starting on the same day, maintain original order (stable sort)
                    // by comparing their dayIdx values for starting items, or use item ID as tiebreaker
                    return a.dayIdx - b.dayIdx;
                  }
                  return dateA - dateB;
                });

                // Assign row numbers - items can share a row if they don't overlap
                // Track occupied column ranges for each row
                const rowOccupancy = []; // Array of arrays: [{ startCol, endCol }, ...]

                weekItems.forEach((item) => {
                  // Calculate the actual column range for this item
                  let startCol, endCol;
                  if (item.isContinuation) {
                    // For continuations, they always start from the beginning of the week (column 0)
                    startCol = 0;
                    const daysUntilWeekEnd = 7;
                    const daysUntilItemEnd = Math.ceil((item.item.endDate - week[0]) / (1000 * 60 * 60 * 24)) + 1;
                    endCol = Math.min(daysUntilItemEnd, daysUntilWeekEnd);
                  } else {
                    // For starting items, calculate based on actual item end date within this week
                    startCol = item.dayIdx;
                    const weekEndDate = new Date(week[6]); // Last day of the week
                    weekEndDate.setHours(23, 59, 59, 999);
                    const itemEndInWeek = Math.ceil((item.item.endDate - item.item.startDate) / (1000 * 60 * 60 * 24)) + 1;
                    const itemEndColAbsolute = item.dayIdx + itemEndInWeek;
                    endCol = Math.min(itemEndColAbsolute, 7);
                  }

                  // Find the first row where this item doesn't overlap
                  let assignedRow = -1;
                  for (let rowIdx = 0; rowIdx < rowOccupancy.length; rowIdx++) {
                    const occupiedRanges = rowOccupancy[rowIdx];
                    let canFitInRow = true;

                    // Check if this item overlaps with any occupied range in this row
                    for (const range of occupiedRanges) {
                      // Items overlap if: itemStart < rangeEnd AND itemEnd > rangeStart
                      if (startCol < range.endCol && endCol > range.startCol) {
                        canFitInRow = false;
                        break;
                      }
                    }

                    if (canFitInRow) {
                      assignedRow = rowIdx;
                      occupiedRanges.push({ startCol: startCol, endCol: endCol });
                      break;
                    }
                  }

                  // If no suitable row found, create a new one
                  if (assignedRow === -1) {
                    assignedRow = rowOccupancy.length;
                    rowOccupancy.push([{ startCol: startCol, endCol: endCol }]);
                  }

                  // Store calculated column range for rendering
                  item.rowInDay = assignedRow;
                  item.renderStartCol = startCol;
                  item.renderEndCol = endCol;
                });
              %>
              <% weekItems.forEach((itemData) => { %>
                <%
                  const { item, dayIdx, rowInDay, isContinuation, renderStartCol, renderEndCol } = itemData;
                  // Use pre-calculated column range for rendering
                  const daysSpanned = renderEndCol - renderStartCol;
              %>
                    <% if (item.type === 'trip') { %>
                      <% const tripColor = item.data.purpose === 'business' ? getItemHexColor('business') : getItemHexColor('trip'); %>
                      <div class="multi-day-bar calendar-item <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %>" data-item-id="<%= itemData.itemId %>" data-item-type="trip" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= tripColor %>33; color: <%= tripColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= tripColor %>;">luggage</span>
                        <span class="truncate"><%= item.data.name %></span>
                      </div>
                    <% } else if (item.type === 'flight') { %>
                      <% const flightColor = getItemHexColor('flight'); %>
                      <div class="multi-day-bar calendar-item" data-item-id="<%= itemData.itemId %>" data-item-type="flight" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= flightColor %>33; color: <%= flightColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= flightColor %>;">flight</span>
                        <span class="truncate"><%= item.data.origin ? item.data.origin.substring(0, 3).toUpperCase() : '' %>→<%= item.data.destination ? item.data.destination.substring(0, 3).toUpperCase() : '' %></span>
                      </div>
                    <% } else if (item.type === 'hotel') { %>
                      <% const hotelColor = getItemHexColor('hotel'); %>
                      <div class="multi-day-bar calendar-item" data-item-id="<%= itemData.itemId %>" data-item-type="hotel" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= hotelColor %>33; color: <%= hotelColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= hotelColor %>;">hotel</span>
                        <span class="truncate"><%= item.data.hotelName %></span>
                      </div>
                    <% } else if (item.type === 'event') { %>
                      <% const eventColor = getItemHexColor('event'); %>
                      <div class="multi-day-bar calendar-item <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %>" data-item-id="<%= itemData.itemId %>" data-item-type="event" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= eventColor %>33; color: <%= eventColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= eventColor %>;">event</span>
                        <span class="truncate"><%= item.data.name %></span>
                      </div>
                    <% } else if (item.type === 'transportation') { %>
                      <% const transColor = getItemHexColor('transportation'); %>
                      <div class="multi-day-bar calendar-item" data-item-id="<%= itemData.itemId %>" data-item-type="transportation" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= transColor %>33; color: <%= transColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= transColor %>;"><%= getTransportationIcon(item.data.method) %></span>
                        <span class="truncate"><%= item.data.origin %> → <%= item.data.destination %></span>
                      </div>
                    <% } else if (item.type === 'carRental') { %>
                      <% const carRentalColor = getItemHexColor('carRental'); %>
                      <div class="multi-day-bar calendar-item" data-item-id="<%= itemData.itemId %>" data-item-type="carRental" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= carRentalColor %>33; color: <%= carRentalColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= carRentalColor %>;">directions_car</span>
                        <span class="truncate"><%= item.data.company %></span>
                      </div>
                    <% } %>
                <% }) %>
            </div>

            <!-- Grid with date cells (empty - just shows days) -->
            <div class="calendar-week">
              <!-- Month label column -->
              <div class="text-xs font-semibold text-gray-500 p-1 text-right pr-8">
                <% if (monthLabelForWeek) { %>
                  <%= monthLabelForWeek.month %> '<%= monthLabelForWeek.year %>
                <% } %>
              </div>

              <!-- Render empty date cells -->
              <% week.forEach((date, dayIdx) => { %>
                <%
                  const dateKey = getDateKey(date);
                  const isToday = dateKey === getDateKey(today);
                  const isPast = date < today;
                %>
                <div class="calendar-date-cell bg-white hover:shadow-sm transition-shadow <% if (isToday) { %>bg-blue-50<% } %><% if (isPast && !isToday) { %>opacity-50<% } %>" style="<% if (!isToday && !isPast) { %>opacity: 0.75;<% } %>" id="date-<%= dateKey %>" data-date="<%= dateKey %>">
                  <div class="text-xs font-semibold <%= isToday ? 'text-blue-700' : 'text-gray-800' %> mb-1">
                    <%= date.getDate() %>
                  </div>
                </div>
              <% }) %>
            </div>
          </div>
        <% }) %>
      </div>

      <!-- Navigation controls at bottom -->
      <div class="sticky bottom-0 border-t border-gray-200 bg-white p-3 flex gap-2 justify-center">
        <button onclick="loadCalendarRange('prev')" class="px-3 py-1 text-xs font-medium text-gray-700 bg-gray-100 rounded hover:bg-gray-200">
          ← Previous months
        </button>
        <button onclick="scrollToToday()" class="px-3 py-1 text-xs font-medium text-blue-600 bg-blue-50 rounded hover:bg-blue-100">
          Today
        </button>
        <button onclick="loadCalendarRange('next')" class="px-3 py-1 text-xs font-medium text-gray-700 bg-gray-100 rounded hover:bg-gray-200">
          Next months →
        </button>
      </div>
      </div>
    </div>

    <!-- Year view (hidden by default) -->
    <div id="calendar-view-year" class="calendar-view flex-1 overflow-auto" style="display: none;">
      <%- include('./calendar-sidebar-week-view') %>
    </div>
  </div>
</div>

<style>
  .calendar-sidebar {
    display: flex;
    flex-direction: column;
  }
  .calendar-sidebar > div {
    flex: 1;
    overflow-y: auto;
  }

  /* Week wrapper - contains both grid and floating layer */
  .calendar-week-wrapper {
    position: relative;
    margin-top: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  /* Floating layer for multi-day items - positioned absolutely over the grid */
  .calendar-multi-day-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  /* Multi-day bar item - floating absolutely positioned */
  .multi-day-bar {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.5rem;
    pointer-events: auto;
    /* Use CSS Grid column tracking for responsive positioning */
    /* Calculate left position: 35px label width + start-col columns worth of width */
    left: calc(35px + var(--start-col) * calc((100% - 35px) / 7) + 0.5rem);
    /* Width calculation: responsive - span columns with responsive column width */
    width: calc(var(--span) * calc((100% - 35px) / 7) - 1rem);
    /* Vertical positioning: float to top with stacking below date number */
    /* Account for date cell padding (0.5rem) + date text height (~1rem) + margin (0.25rem) */
    top: calc(1.75rem + var(--row-in-day) * 1.75rem);
  }

  /* Calendar item styling */
  .calendar-item {
    cursor: pointer;
  }

  .calendar-item:hover {
    opacity: 0.85;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  /* Tentative item styling - diagonal stripes overlay */
  .calendar-item-tentative::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.1) 2px,
      rgba(0, 0, 0, 0.1) 4px
    );
    pointer-events: none;
    border-radius: 0.25rem;
  }

  /* Week grid container - fixed column widths */
  .calendar-week {
    display: grid;
    grid-template-columns: 35px repeat(7, minmax(120px, 1fr));
    gap: 0;
    margin-top: 0;
    width: 100%;
  }

  /* Date cell - individual day container */
  .calendar-date-cell {
    border-left: 2px solid rgba(229, 231, 235, var(--tw-border-opacity));
    padding: 0.5rem;
    overflow: visible;
    position: relative;
    display: flex;
    flex-direction: column;
    min-height: 160px;
    width: 100%;
  }

  /* Stack single-day items vertically */
  .single-day-items {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    overflow: hidden;
  }

  .single-day-items > div {
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    min-width: 0; /* Allow flex children to shrink below content size */
  }

  .single-day-items > div > span {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Calendar item detail panel - small popup */
  .calendar-item-detail-panel {
    position: fixed;
    background: white;
    border-radius: 0.375rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
    z-index: 9999;
    animation: popIn 0.15s ease-out;
    border: 1px solid #e5e7eb;
    padding: 0.5rem 0.75rem;
    max-width: 200px;
    pointer-events: auto;
  }

  @keyframes popIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  .detail-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    font-size: 0.8125rem;
  }

  .detail-info strong {
    color: #1f2937;
    font-weight: 600;
    word-break: break-word;
    line-height: 1.3;
  }

  .detail-type {
    color: #6b7280;
    font-size: 0.75rem;
    text-transform: capitalize;
    font-weight: 500;
  }

  /* Flight detail styling */
  .flight-detail {
    gap: 0.5rem !important;
  }

  .flight-segment {
    display: flex;
    align-items: flex-start;
    gap: 0.375rem;
  }

  .flight-segment .material-symbols-outlined {
    font-size: 1rem;
    color: #3b82f6;
    flex-shrink: 0;
    margin-top: 0.05rem;
  }

  .segment-info {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
  }

  .segment-info strong {
    color: #1f2937;
    font-weight: 700;
    font-size: 0.8125rem;
  }

  .segment-info .time {
    color: #6b7280;
    font-size: 0.7rem;
    font-weight: 400;
  }

  /* Hotel detail styling */
  .hotel-detail {
    gap: 0.375rem !important;
  }

  .hotel-detail .detail-type {
    color: #6b7280;
    font-size: 0.7rem;
  }

  .hotel-detail .hotel-info {
    font-size: 0.75rem;
  }

  .hotel-detail .hotel-info strong {
    display: block;
    color: #1f2937;
    font-weight: 700;
    margin-bottom: 0.125rem;
  }

  .hotel-detail .hotel-dates,
  .hotel-detail .hotel-address,
  .hotel-detail .hotel-phone {
    font-size: 0.7rem;
    color: #6b7280;
    line-height: 1.3;
  }
</style>

<script>
  // Store flight and hotel data for detail panel display
  window.calendarFlightData = {};
  window.calendarHotelData = {};

  // Collect flight and hotel data from all trips and standalone items
  const allFlights = [];
  const trips = <%- JSON.stringify(trips || []) %>;
  const standaloneFlights = <%- JSON.stringify(standaloneFlights || []) %>;
  const standaloneHotels = <%- JSON.stringify(standaloneHotels || []) %>;

  // Collect flights from trips
  trips.forEach(trip => {
    if (trip.flights) {
      trip.flights.forEach(flight => {
        window.calendarFlightData[flight.id] = flight;
      });
    }
    // Collect hotels from trips
    if (trip.hotels) {
      trip.hotels.forEach(hotel => {
        window.calendarHotelData[hotel.id] = hotel;
      });
    }
  });

  // Collect standalone flights
  standaloneFlights.forEach(flight => {
    window.calendarFlightData[flight.id] = flight;
  });

  // Collect standalone hotels
  standaloneHotels.forEach(hotel => {
    window.calendarHotelData[hotel.id] = hotel;
  });

  // Calendar view management
  let currentCalendarView = localStorage.getItem('calendarView') || 'week';

  /**
   * Toggle between week and year calendar views
   */
  function toggleCalendarView() {
    const weekView = document.getElementById('calendar-view-week');
    const yearView = document.getElementById('calendar-view-year');
    const toggleIcon = document.getElementById('toggle-icon');

    if (currentCalendarView === 'week') {
      // Switch to year view
      currentCalendarView = 'year';
      weekView.style.display = 'none';
      yearView.style.display = 'block';
      toggleIcon.textContent = 'calendar_month';
    } else {
      // Switch to week view
      currentCalendarView = 'week';
      weekView.style.display = 'block';
      yearView.style.display = 'none';
      toggleIcon.textContent = 'view_week';
    }

    // Save preference to localStorage
    localStorage.setItem('calendarView', currentCalendarView);
  }

  /**
   * Initialize calendar view on load
   */
  function initializeCalendarView() {
    const weekView = document.getElementById('calendar-view-week');
    const yearView = document.getElementById('calendar-view-year');
    const toggleIcon = document.getElementById('toggle-icon');

    if (currentCalendarView === 'year') {
      weekView.style.display = 'none';
      yearView.style.display = 'block';
      toggleIcon.textContent = 'calendar_month';
    } else {
      weekView.style.display = 'block';
      yearView.style.display = 'none';
      toggleIcon.textContent = 'view_week';
    }
  }

  // Scroll to the first day of current month
  function scrollToCurrentMonth() {
    const scrollContainer = document.getElementById('calendar-scroll');
    if (!scrollContainer) return;

    // Create a date for the first day of current month
    const currentMonthStart = new Date();
    currentMonthStart.setDate(1);
    currentMonthStart.setHours(0, 0, 0, 0);

    const year = currentMonthStart.getFullYear();
    const month = String(currentMonthStart.getMonth() + 1).padStart(2, '0');
    const day = String(currentMonthStart.getDate()).padStart(2, '0');
    const dateKey = `${year}-${month}-${day}`;

    const firstDayElement = document.getElementById('date-' + dateKey);

    if (firstDayElement) {
      // Use scrollIntoView for more reliable scrolling
      firstDayElement.scrollIntoView({ behavior: 'auto', block: 'start' });

      // Fine-tune the scroll position to move up slightly so we see some context
      setTimeout(() => {
        const offsetTop = firstDayElement.offsetTop;
        scrollContainer.scrollTop = Math.max(0, offsetTop - 100);
      }, 10);
    }
  }

  // Function to load additional calendar months
  async function loadCalendarRange(direction) {
    try {
      const button = event.target;
      button.disabled = true;
      const originalText = button.textContent;
      button.textContent = 'Loading...';

      const response = await fetch('/calendar/range', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ direction }),
      });

      if (response.ok) {
        const html = await response.text();
        // Insert the new months HTML before the navigation buttons
        const navButtons = document.querySelector('.sticky.bottom-0');
        const newDiv = document.createElement('div');
        newDiv.innerHTML = html;
        navButtons.parentElement.insertBefore(newDiv, navButtons);
      }
    } catch (error) {
      // Silently fail for now
    } finally {
      if (button) {
        button.disabled = false;
        button.textContent = originalText;
      }
    }
  }

  // Make toggleCalendarView globally available
  window.toggleCalendarView = toggleCalendarView;

  // Calendar item detail panel functionality
  function initializeCalendarItemClicks() {
    const calendarItems = document.querySelectorAll('.calendar-item');

    calendarItems.forEach(item => {
      item.addEventListener('click', function(e) {
        e.stopPropagation();
        const itemId = this.dataset.itemId;
        const itemType = this.dataset.itemType;

        // Extract display text from the clicked element
        let displayText = '';
        const textSpans = this.querySelectorAll('.truncate');
        if (textSpans.length > 0) {
          displayText = textSpans[0].textContent;
        }

        // Show detail panel next to the clicked item
        showItemDetailPanel(this, itemType, itemId, displayText);
      });
    });
  }

  function showItemDetailPanel(clickedElement, itemType, itemId, displayText) {
    // Close any existing panel
    closeItemDetailPanel();

    // Create detail panel
    const panel = document.createElement('div');
    panel.id = 'calendar-item-detail-panel';
    panel.className = 'calendar-item-detail-panel';

    // Set content based on item type
    let content = '';

    if (itemType === 'flight') {
      // Find the actual flight data from the document
      const flightData = window.calendarFlightData && window.calendarFlightData[itemId];
      if (flightData) {
        const depTime = new Date(flightData.departureDateTime);
        const arrTime = new Date(flightData.arrivalDateTime);

        const depCode = flightData.origin ? flightData.origin.substring(0, 3).toUpperCase() : '';
        const arrCode = flightData.destination ? flightData.destination.substring(0, 3).toUpperCase() : '';

        const depFormatted = formatDetailDateTime(depTime);
        const arrFormatted = formatDetailDateTime(arrTime);

        content = `
          <div class="detail-info flight-detail">
            <div class="flight-segment">
              <span class="material-symbols-outlined">flight_takeoff</span>
              <div class="segment-info">
                <strong>${depCode}</strong>
                <span class="time">${depFormatted}</span>
              </div>
            </div>
            <div class="flight-segment">
              <span class="material-symbols-outlined">flight_land</span>
              <div class="segment-info">
                <strong>${arrCode}</strong>
                <span class="time">${arrFormatted}</span>
              </div>
            </div>
          </div>
        `;
      } else {
        content = `<div class="detail-info"><strong>${escapeHtml(displayText || 'Flight')}</strong><span class="detail-type">${itemType}</span></div>`;
      }
    } else if (itemType === 'hotel') {
      // Find the actual hotel data from the document
      const hotelData = window.calendarHotelData && window.calendarHotelData[itemId];
      if (hotelData) {
        const checkInDate = new Date(hotelData.checkInDateTime);
        const checkOutDate = new Date(hotelData.checkOutDateTime);

        const checkInFormatted = formatDetailDateTime(checkInDate);
        const checkOutFormatted = formatDetailDateTime(checkOutDate);

        content = `
          <div class="detail-info hotel-detail">
            <div class="hotel-info">
              <strong>${escapeHtml(hotelData.hotelName || 'Hotel')}</strong>
            </div>
            <div class="hotel-dates">${checkInFormatted} - ${checkOutFormatted}</div>
            ${hotelData.address ? `<div class="hotel-address">${escapeHtml(hotelData.address)}</div>` : ''}
            ${hotelData.phone ? `<div class="hotel-phone">${escapeHtml(hotelData.phone)}</div>` : ''}
          </div>
        `;
      } else {
        content = `<div class="detail-info"><strong>${escapeHtml(displayText || 'Hotel')}</strong><span class="detail-type">${itemType}</span></div>`;
      }
    } else {
      content = `
        <div class="detail-info">
          <strong>${escapeHtml(displayText || 'Item')}</strong>
          <span class="detail-type">${itemType}</span>
        </div>
      `;
    }

    panel.innerHTML = content;
    document.body.appendChild(panel);

    // Position the panel next to the clicked element
    positionDetailPanel(panel, clickedElement);

    // Add click handler to close panel when clicking outside
    setTimeout(() => {
      document.addEventListener('click', closeDetailPanelOnOutsideClick);
    }, 50);
  }

  function formatDetailDateTime(date) {
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    const day = String(date.getDate()).padStart(2, '0');
    const month = months[date.getMonth()];
    const hour = String(date.getHours()).padStart(2, '0');
    const min = String(date.getMinutes()).padStart(2, '0');

    return `${day} ${month} ${hour}:${min}`;
  }

  function positionDetailPanel(panel, itemElement) {
    // Get the position of the clicked item
    const rect = itemElement.getBoundingClientRect();

    // Try to position above the item first
    let top = rect.top - panel.offsetHeight - 8;
    let left = rect.left + (rect.width / 2) - (panel.offsetWidth / 2);

    // If panel would go off-screen above, position below instead
    if (top < 10) {
      top = rect.bottom + 8;
    }

    // Keep panel within horizontal bounds
    if (left < 10) {
      left = 10;
    } else if (left + panel.offsetWidth > window.innerWidth - 10) {
      left = window.innerWidth - panel.offsetWidth - 10;
    }

    panel.style.top = top + 'px';
    panel.style.left = left + 'px';
  }

  function closeItemDetailPanel() {
    const panel = document.getElementById('calendar-item-detail-panel');
    if (panel) {
      panel.remove();
      document.removeEventListener('click', closeDetailPanelOnOutsideClick);
    }
  }

  function closeDetailPanelOnOutsideClick(e) {
    const panel = document.getElementById('calendar-item-detail-panel');
    if (panel && !panel.contains(e.target) && !e.target.classList.contains('calendar-item')) {
      closeItemDetailPanel();
    }
  }

  function escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
  }

  // Initialize on load
  window.closeItemDetailPanel = closeItemDetailPanel;

  // Auto-scroll to current month/week on calendar load
  // Use a small timeout to ensure the DOM is fully rendered
  setTimeout(() => {
    initializeCalendarView();
    if (typeof scrollToCurrentMonth === 'function') {
      scrollToCurrentMonth();
    }
    // Initialize calendar item click handlers
    initializeCalendarItemClicks();
  }, 50);

</script>
