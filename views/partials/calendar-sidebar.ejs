<%
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; // Monday start

  function getDateKey(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  function getMondayColumn(date) {
    // Returns 0-6 where 0 = Monday, 6 = Sunday
    const dayOfWeek = date.getDay();
    return dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  }

  // Create today's date in local timezone
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Helper function to parse DATEONLY strings (YYYY-MM-DD format)
  const parseDateOnly = (dateStr) => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day, 0, 0, 0, 0);
    return date;
  };

  // Calculate date range: show 13 months total
  // Last month + current month + next 11 months
  const startDate = new Date(today);
  startDate.setMonth(today.getMonth() - 1); // 1 month back
  startDate.setDate(1);

  const endDate = new Date(today);
  endDate.setMonth(today.getMonth() + 11); // 11 months forward
  endDate.setDate(0); // Last day of month

  // Build a flat list of all dates in range with their items
  const dateToItems = {}; // { dateKey: [{ type, data }] }
  const allDates = []; // All dates in order for continuous layout

  // Generate all dates in range
  let currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const key = getDateKey(currentDate);
    dateToItems[key] = [];
    allDates.push(new Date(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Add trips to dates
  const safeTrips = trips || [];
  safeTrips.forEach(trip => {
    if (!trip.departureDate || !trip.returnDate) return;

    const depDate = parseDateOnly(trip.departureDate);
    const retDate = parseDateOnly(trip.returnDate);

    // For multi-day trips, only add to start date with duration info
    const durationDays = Math.ceil((retDate - depDate) / (1000 * 60 * 60 * 24)) + 1;
    const startKey = getDateKey(depDate);
    if (dateToItems[startKey]) {
      dateToItems[startKey].push({
        type: 'trip',
        data: trip,
        startDate: depDate,
        endDate: retDate,
        durationDays: durationDays
      });
    }

    // Add items within the trip (flights, hotels, transportation, car rentals, events)
    if (trip.flights) {
      trip.flights.forEach(flight => {
        if (!flight.departureDateTime) return;
        const startDate = new Date(flight.departureDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
        endDate.setHours(0, 0, 0, 0);
        const flightDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays: flightDurationDays });
        }
      });
    }

    if (trip.hotels) {
      trip.hotels.forEach(hotel => {
        if (!hotel.checkInDateTime) return;
        const startDate = new Date(hotel.checkInDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
        endDate.setHours(0, 0, 0, 0);
        const hotelDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays: hotelDurationDays });
        }
      });
    }

    if (trip.transportation) {
      trip.transportation.forEach(trans => {
        if (!trans.departureDateTime) return;
        const startDate = new Date(trans.departureDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
        endDate.setHours(0, 0, 0, 0);
        const transDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays: transDurationDays });
        }
      });
    }

    if (trip.carRentals) {
      trip.carRentals.forEach(carRental => {
        if (!carRental.pickupDateTime) return;
        const startDate = new Date(carRental.pickupDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
        endDate.setHours(0, 0, 0, 0);
        const carDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays: carDurationDays });
        }
      });
    }

    if (trip.events) {
      trip.events.forEach(event => {
        if (!event.startDateTime) return;
        const startDate = new Date(event.startDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(event.endDateTime || event.startDateTime);
        endDate.setHours(0, 0, 0, 0);
        const eventDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (dateToItems[key]) {
          dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays: eventDurationDays });
        }
      });
    }
  });

  // Add standalone items (flights, hotels, transportation, events not part of trips)
  const safeStandaloneFlights = standaloneFlights || [];
  const safeStandaloneHotels = standaloneHotels || [];
  const safeStandaloneTransportation = standaloneTransportation || [];
  const safeStandaloneCarRentals = standaloneCarRentals || [];
  const safeStandaloneEvents = standaloneEvents || [];

  // Add standalone flights
  safeStandaloneFlights.forEach(flight => {
    if (!flight.departureDateTime) return;
    const startDate = new Date(flight.departureDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays });
    }
  });

  // Add standalone hotels
  safeStandaloneHotels.forEach(hotel => {
    if (!hotel.checkInDateTime) return;
    const startDate = new Date(hotel.checkInDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays });
    }
  });

  // Add standalone transportation
  safeStandaloneTransportation.forEach(trans => {
    if (!trans.departureDateTime) return;
    const startDate = new Date(trans.departureDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays });
    }
  });

  // Add standalone car rentals
  safeStandaloneCarRentals.forEach(carRental => {
    if (!carRental.pickupDateTime) return;
    const startDate = new Date(carRental.pickupDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays });
    }
  });

  // Add standalone events
  safeStandaloneEvents.forEach(event => {
    if (!event.startDateTime) return;
    const startDate = new Date(event.startDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(event.endDateTime || event.startDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (dateToItems[key]) {
      dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays });
    }
  });

  // Function to get transportation icon based on method
  function getTransportationIcon(method) {
    const iconMap = {
      'train': 'train',
      'bus': 'directions_bus',
      'ferry': 'directions_boat',
      'shuttle': 'airport_shuttle',
      'taxi': 'hail',
      'rideshare': 'hail',
      'taxi/rideshare': 'hail',
      'subway': 'directions_subway',
      'metro': 'directions_subway',
      'subway/metro': 'directions_subway',
      'tram': 'tram',
      'funicular': 'funicular',
      'gondola': 'gondola_lift',
      'monorail': 'monorail',
      'other': 'directions_run'
    };
    return iconMap[method?.toLowerCase()] || 'transportation';
  }

  // Helper function to check if an item spans multiple days
  function isMultiDay(item) {
    return item.durationDays > 1;
  }

  // Helper function to find the grid column index for a date
  function getDateGridColumn(dateKey, weeks, dayNames) {
    for (let weekIdx = 0; weekIdx < weeks.length; weekIdx++) {
      for (let dayIdx = 0; dayIdx < weeks[weekIdx].length; dayIdx++) {
        if (getDateKey(weeks[weekIdx][dayIdx]) === dateKey) {
          return { weekIdx, dayIdx };
        }
      }
    }
    return null;
  }

  // Generate calendar weeks (Monday-Sunday)
  const weeks = [];
  let weekDates = [];

  // Start with the Monday of the first week
  let calendarStart = new Date(startDate);
  const mondayCol = getMondayColumn(calendarStart);
  calendarStart.setDate(calendarStart.getDate() - mondayCol);

  currentDate = new Date(calendarStart);
  while (currentDate <= endDate) {
    weekDates.push(new Date(currentDate));

    if (weekDates.length === 7) {
      weeks.push(weekDates);
      weekDates = [];
    }

    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Add remaining dates as final week if needed
  if (weekDates.length > 0) {
    weeks.push(weekDates);
  }

  // Track which multi-day items have been rendered to avoid duplicates
  const renderedMultiDayItems = new Set();

%>

<div class="calendar-sidebar h-full flex flex-col">
  <div class="flex flex-1 overflow-hidden">
    <!-- Calendar content -->
    <div class="flex-1 overflow-y-auto" id="calendar-scroll">
      <div class="p-4">
        <!-- Day header -->
        <div class="sticky top-0 z-10 pb-2 mb-0">
          <div class="grid" style="grid-template-columns: 35px repeat(7, 1fr); gap: 0rem;">
            <div class="text-center text-xs font-semibold text-gray-500 p-2"></div>
            <% dayNames.forEach(day => { %>
              <div class="text-center text-xs font-semibold text-gray-600 p-2">
                <%= day %>
              </div>
            <% }) %>
          </div>
        </div>

        <!-- Continuous calendar weeks -->
        <% weeks.forEach((week, weekIdx) => { %>
          <%
            // Check if this week contains the 1st of any month
            let monthLabelForWeek = null;
            week.forEach(day => {
              if (day.getDate() === 1) {
                monthLabelForWeek = {
                  month: monthNames[day.getMonth()].substring(0, 3),
                  year: String(day.getFullYear()).substring(2)
                };
              }
            });
          %>
          <!-- Week row wrapper -->
          <div class="calendar-week-wrapper" data-week="<%= weekIdx %>">
            <!-- Floating items layer (positioned absolutely) -->
            <div class="calendar-multi-day-layer">
              <%
                // Collect all items for this week organized by day and row
                const weekItems = [];

                // First, collect items starting in this week
                week.forEach((date, dayIdx) => {
                  const dateKey = getDateKey(date);
                  const items = dateToItems[dateKey] || [];

                  items.forEach(item => {
                    const itemId = item.data.id;
                    const isFirstDay = dateKey === getDateKey(item.startDate);
                    if (isFirstDay && !renderedMultiDayItems.has(itemId)) {
                      renderedMultiDayItems.add(itemId);
                      weekItems.push({ item, dayIdx, itemId, isContinuation: false });
                    }
                  });
                });

                // Check for items from previous weeks that continue into this week
                if (weekIdx > 0) {
                  const weekStartDate = week[0];
                  const continuationItemsThisWeek = new Set();

                  // Look at ALL items added to dates in previous weeks
                  const allPreviousItems = new Set();
                  for (let prevWeekIdx = 0; prevWeekIdx < weekIdx; prevWeekIdx++) {
                    weeks[prevWeekIdx].forEach((date) => {
                      const dateKey = getDateKey(date);
                      const items = dateToItems[dateKey] || [];
                      items.forEach(item => {
                        allPreviousItems.add(item.data.id);
                      });
                    });
                  }

                  // Check each previous item to see if it continues into this week
                  allPreviousItems.forEach(itemId => {
                    // Find the item in dateToItems
                    let foundItem = null;
                    for (let prevWeekIdx = 0; prevWeekIdx < weekIdx; prevWeekIdx++) {
                      weeks[prevWeekIdx].forEach((date) => {
                        const dateKey = getDateKey(date);
                        const items = dateToItems[dateKey] || [];
                        items.forEach(item => {
                          if (item.data.id === itemId && !foundItem) {
                            foundItem = item;
                          }
                        });
                      });
                    }

                    // If item ends on or after this week's start, it's a continuation
                    if (foundItem && foundItem.endDate >= weekStartDate && !continuationItemsThisWeek.has(itemId)) {
                      continuationItemsThisWeek.add(itemId);
                      weekItems.push({ item: foundItem, dayIdx: 0, itemId, isContinuation: true });
                    }
                  });
                }

                // Sort items by start date ascending (earliest first), with stable sort for items on same day
                weekItems.sort((a, b) => {
                  const dateA = a.item.startDate;
                  const dateB = b.item.startDate;
                  if (dateA.getTime() === dateB.getTime()) {
                    // For items starting on the same day, maintain original order (stable sort)
                    // by comparing their dayIdx values for starting items, or use item ID as tiebreaker
                    return a.dayIdx - b.dayIdx;
                  }
                  return dateA - dateB;
                });

                // Assign row numbers - items can share a row if they don't overlap
                // Track occupied column ranges for each row
                const rowOccupancy = []; // Array of arrays: [{ startCol, endCol }, ...]

                weekItems.forEach((item) => {
                  // Calculate the actual column range for this item
                  let startCol, endCol;
                  if (item.isContinuation) {
                    // For continuations, they always start from the beginning of the week (column 0)
                    startCol = 0;
                    const daysUntilWeekEnd = 7;
                    const daysUntilItemEnd = Math.ceil((item.item.endDate - week[0]) / (1000 * 60 * 60 * 24)) + 1;
                    endCol = Math.min(daysUntilItemEnd, daysUntilWeekEnd);
                  } else {
                    // For starting items, they begin at dayIdx
                    startCol = item.dayIdx;
                    endCol = item.dayIdx + Math.min(item.item.durationDays, 7 - item.dayIdx);
                  }

                  // Find the first row where this item doesn't overlap
                  let assignedRow = -1;
                  for (let rowIdx = 0; rowIdx < rowOccupancy.length; rowIdx++) {
                    const occupiedRanges = rowOccupancy[rowIdx];
                    let canFitInRow = true;

                    // Check if this item overlaps with any occupied range in this row
                    for (const range of occupiedRanges) {
                      // Items overlap if: itemStart < rangeEnd AND itemEnd > rangeStart
                      if (startCol < range.endCol && endCol > range.startCol) {
                        canFitInRow = false;
                        break;
                      }
                    }

                    if (canFitInRow) {
                      assignedRow = rowIdx;
                      occupiedRanges.push({ startCol: startCol, endCol: endCol });
                      break;
                    }
                  }

                  // If no suitable row found, create a new one
                  if (assignedRow === -1) {
                    assignedRow = rowOccupancy.length;
                    rowOccupancy.push([{ startCol: startCol, endCol: endCol }]);
                  }

                  // Store calculated column range for rendering
                  item.rowInDay = assignedRow;
                  item.renderStartCol = startCol;
                  item.renderEndCol = endCol;
                });
              %>
              <% weekItems.forEach((itemData) => { %>
                <%
                  const { item, dayIdx, rowInDay, isContinuation, renderStartCol, renderEndCol } = itemData;
                  // Use pre-calculated column range for rendering
                  const daysSpanned = renderEndCol - renderStartCol;
              %>
                    <% if (item.type === 'trip') { %>
                      <% const tripColor = item.data.purpose === 'business' ? getItemHexColor('business') : getItemHexColor('trip'); %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= tripColor %>33; color: <%= tripColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= tripColor %>;">luggage</span>
                        <span class="truncate"><%= item.data.name %></span>
                      </div>
                    <% } else if (item.type === 'flight') { %>
                      <%
                        // Extract airport codes (first 3 letters)
                        const originCode = item.data.origin ? item.data.origin.substring(0, 3).toUpperCase() : '';
                        const destCode = item.data.destination ? item.data.destination.substring(0, 3).toUpperCase() : '';
                        const flightColor = getItemHexColor('flight');
                      %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= flightColor %>33; color: <%= flightColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= flightColor %>;">flight</span>
                        <span class="truncate"><%= originCode %>→<%= destCode %></span>
                      </div>
                    <% } else if (item.type === 'hotel') { %>
                      <% const hotelColor = getItemHexColor('hotel'); %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= hotelColor %>33; color: <%= hotelColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= hotelColor %>;">hotel</span>
                        <span class="truncate"><%= item.data.hotelName %></span>
                      </div>
                    <% } else if (item.type === 'event') { %>
                      <% const eventColor = getItemHexColor('event'); %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= eventColor %>33; color: <%= eventColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= eventColor %>;">event</span>
                        <span class="truncate"><%= item.data.name %></span>
                      </div>
                    <% } else if (item.type === 'transportation') { %>
                      <% const transColor = getItemHexColor('transportation'); %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= transColor %>33; color: <%= transColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= transColor %>;"><%= getTransportationIcon(item.data.method) %></span>
                        <span class="truncate"><%= item.data.origin %> → <%= item.data.destination %></span>
                      </div>
                    <% } else if (item.type === 'carRental') { %>
                      <% const carRentalColor = getItemHexColor('carRental'); %>
                      <div class="multi-day-bar" data-item-id="<%= itemData.itemId %>" data-row="<%= rowInDay %>" data-start-col="<%= renderStartCol %>" data-span="<%= daysSpanned %>" style="--start-col: <%= renderStartCol %>; --span: <%= daysSpanned %>; --row-in-day: <%= rowInDay %>; background-color: <%= carRentalColor %>33; color: <%= carRentalColor %>;">
                        <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= carRentalColor %>;">directions_car</span>
                        <span class="truncate"><%= item.data.company %></span>
                      </div>
                    <% } %>
                <% }) %>
            </div>

            <!-- Grid with date cells (empty - just shows days) -->
            <div class="calendar-week">
              <!-- Month label column -->
              <div class="text-xs font-semibold text-gray-500 p-1 text-right pr-8">
                <% if (monthLabelForWeek) { %>
                  <%= monthLabelForWeek.month %> '<%= monthLabelForWeek.year %>
                <% } %>
              </div>

              <!-- Render empty date cells -->
              <% week.forEach((date, dayIdx) => { %>
                <%
                  const dateKey = getDateKey(date);
                  const isToday = dateKey === getDateKey(today);
                  const isPast = date < today;
                %>
                <div class="calendar-date-cell bg-white opacity-85 hover:shadow-sm transition-shadow <% if (isToday) { %>bg-blue-50 opacity-100<% } %><% if (isPast && !isToday) { %>opacity-50<% } %>" id="date-<%= dateKey %>" data-date="<%= dateKey %>">
                  <div class="text-xs font-semibold <%= isToday ? 'text-blue-700' : 'text-gray-800' %> mb-1">
                    <%= date.getDate() %>
                  </div>
                </div>
              <% }) %>
            </div>
          </div>
        <% }) %>
      </div>

      <!-- Navigation controls at bottom -->
      <div class="sticky bottom-0 border-t border-gray-200 bg-white p-3 flex gap-2 justify-center">
        <button onclick="loadCalendarRange('prev')" class="px-3 py-1 text-xs font-medium text-gray-700 bg-gray-100 rounded hover:bg-gray-200">
          ← Previous months
        </button>
        <button onclick="scrollToToday()" class="px-3 py-1 text-xs font-medium text-blue-600 bg-blue-50 rounded hover:bg-blue-100">
          Today
        </button>
        <button onclick="loadCalendarRange('next')" class="px-3 py-1 text-xs font-medium text-gray-700 bg-gray-100 rounded hover:bg-gray-200">
          Next months →
        </button>
      </div>
    </div>
  </div>
</div>

<style>
  .calendar-sidebar {
    display: flex;
    flex-direction: column;
  }
  .calendar-sidebar > div {
    flex: 1;
    overflow-y: auto;
  }

  /* Week wrapper - contains both grid and floating layer */
  .calendar-week-wrapper {
    position: relative;
    margin-top: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  /* Floating layer for multi-day items - positioned absolutely over the grid */
  .calendar-multi-day-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  /* Multi-day bar item - floating absolutely positioned */
  .multi-day-bar {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.5rem;
    pointer-events: auto;
    /* Use CSS Grid column tracking for responsive positioning */
    /* Calculate left position: 35px label width + start-col columns worth of width */
    left: calc(35px + var(--start-col) * calc((100% - 35px) / 7) + 0.5rem);
    /* Width calculation: responsive - span columns with responsive column width */
    width: calc(var(--span) * calc((100% - 35px) / 7) - 1rem);
    /* Vertical positioning: float to top with stacking below date number */
    /* Account for date cell padding (0.5rem) + date text height (~1rem) + margin (0.25rem) */
    top: calc(1.75rem + var(--row-in-day) * 1.75rem);
  }

  /* Week grid container - fixed column widths */
  .calendar-week {
    display: grid;
    grid-template-columns: 35px repeat(7, minmax(120px, 1fr));
    gap: 0;
    margin-top: 0;
    width: 100%;
  }

  /* Date cell - individual day container */
  .calendar-date-cell {
    border-left: 2px solid rgba(229, 231, 235, var(--tw-border-opacity));
    padding: 0.5rem;
    overflow: visible;
    position: relative;
    display: flex;
    flex-direction: column;
    min-height: 120px;
    width: 100%;
  }

  /* Stack single-day items vertically */
  .single-day-items {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    overflow: hidden;
  }

  .single-day-items > div {
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    min-width: 0; /* Allow flex children to shrink below content size */
  }

  .single-day-items > div > span {
    overflow: hidden;
    text-overflow: ellipsis;
  }
</style>

<script>
  // Scroll to the first day of current month
  function scrollToCurrentMonth() {
    const scrollContainer = document.getElementById('calendar-scroll');
    if (!scrollContainer) return;

    // Create a date for the first day of current month
    const currentMonthStart = new Date();
    currentMonthStart.setDate(1);
    currentMonthStart.setHours(0, 0, 0, 0);

    const year = currentMonthStart.getFullYear();
    const month = String(currentMonthStart.getMonth() + 1).padStart(2, '0');
    const day = String(currentMonthStart.getDate()).padStart(2, '0');
    const dateKey = `${year}-${month}-${day}`;

    const firstDayElement = document.getElementById('date-' + dateKey);

    if (firstDayElement) {
      // Use scrollIntoView for more reliable scrolling
      firstDayElement.scrollIntoView({ behavior: 'auto', block: 'start' });

      // Fine-tune the scroll position to move up slightly so we see some context
      setTimeout(() => {
        const offsetTop = firstDayElement.offsetTop;
        scrollContainer.scrollTop = Math.max(0, offsetTop - 100);
      }, 10);
    }
  }

  // Function to load additional calendar months
  async function loadCalendarRange(direction) {
    try {
      const button = event.target;
      button.disabled = true;
      const originalText = button.textContent;
      button.textContent = 'Loading...';

      const response = await fetch('/calendar/range', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ direction }),
      });

      if (response.ok) {
        const html = await response.text();
        // Insert the new months HTML before the navigation buttons
        const navButtons = document.querySelector('.sticky.bottom-0');
        const newDiv = document.createElement('div');
        newDiv.innerHTML = html;
        navButtons.parentElement.insertBefore(newDiv, navButtons);
      }
    } catch (error) {
      // Silently fail for now
    } finally {
      if (button) {
        button.disabled = false;
        button.textContent = originalText;
      }
    }
  }

  // Auto-scroll to current month on initial load
  // Use a small delay to ensure the layout is fully rendered
  setTimeout(() => {
    scrollToCurrentMonth();
  }, 50);
</script>
