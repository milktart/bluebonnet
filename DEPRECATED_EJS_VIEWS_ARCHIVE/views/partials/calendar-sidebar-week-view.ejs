<%
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  // Get today's date
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Calculate 19-month range: 3 months back, current month, 15 months forward
  const startMonth = new Date(today);
  startMonth.setMonth(today.getMonth() - 3);
  startMonth.setDate(1);

  const endMonth = new Date(today);
  endMonth.setMonth(today.getMonth() + 15);
  endMonth.setDate(1);

  // Helper function to get date key
  function getDateKey(date) {
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Helper function to parse DATEONLY strings
  const parseDateOnly = (dateStr) => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day, 0, 0, 0, 0);
    return date;
  };

  // Helper function to normalize a date to midnight (removes time component)
  const normalizeDate = (date) => {
    const normalized = new Date(date);
    normalized.setHours(0, 0, 0, 0);
    return normalized;
  };

  // Build dateToItems map from trips and standalone items
  const dateToItems = {}; // { dateKey: [{ type, data, startDate, endDate, durationDays }] }

  // Add trips to dates
  const safeTrips = trips || [];
  safeTrips.forEach(trip => {
    if (!trip.departureDate || !trip.returnDate) return;

    const depDate = parseDateOnly(trip.departureDate);
    const retDate = parseDateOnly(trip.returnDate);

    const durationDays = Math.ceil((retDate - depDate) / (1000 * 60 * 60 * 24)) + 1;
    const startKey = getDateKey(depDate);
    if (!dateToItems[startKey]) dateToItems[startKey] = [];
    dateToItems[startKey].push({
      type: 'trip',
      data: trip,
      startDate: depDate,
      endDate: retDate,
      durationDays: durationDays
    });

    // Add flights
    if (trip.flights) {
      trip.flights.forEach(flight => {
        if (!flight.departureDateTime) return;
        // Convert UTC departure time to origin airport's local timezone
        let startDate = new Date(flight.departureDateTime);
        if (flight.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        // Convert UTC arrival time to destination airport's local timezone
        let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
        if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const flightDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (!dateToItems[key]) dateToItems[key] = [];
        dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays: flightDurationDays });
      });
    }

    // Add hotels
    if (trip.hotels) {
      trip.hotels.forEach(hotel => {
        if (!hotel.checkInDateTime) return;
        // Convert UTC check-in time to hotel's local timezone
        let startDate = new Date(hotel.checkInDateTime);
        if (hotel.timezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(hotel.checkInDateTime, hotel.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
        } else {
          startDate.setHours(0, 0, 0, 0);
        }
        // Convert UTC check-out time to hotel's local timezone
        let endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
        if (hotel.timezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(hotel.checkOutDateTime || hotel.checkInDateTime, hotel.timezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
        } else {
          endDate.setHours(0, 0, 0, 0);
        }
        const hotelDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (!dateToItems[key]) dateToItems[key] = [];
        dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays: hotelDurationDays });
      });
    }

    // Add transportation
    if (trip.transportation) {
      trip.transportation.forEach(trans => {
        if (!trans.departureDateTime) return;
        let startDate = new Date(trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedDate.split('-').map(Number);
          startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          startDate.setHours(0, 0, 0, 0);
        }

        let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
        if (trans.originTimezone && typeof formatInTimezone === 'function') {
          const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
          const [year, month, day] = formattedEndDate.split('-').map(Number);
          endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
        } else {
          endDate.setHours(0, 0, 0, 0);
        }

        const transDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (!dateToItems[key]) dateToItems[key] = [];
        dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays: transDurationDays });
      });
    }

    // Add car rentals
    if (trip.carRentals) {
      trip.carRentals.forEach(carRental => {
        if (!carRental.pickupDateTime) return;
        const startDate = new Date(carRental.pickupDateTime);
        startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
        endDate.setHours(0, 0, 0, 0);
        const carDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (!dateToItems[key]) dateToItems[key] = [];
        dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays: carDurationDays });
      });
    }

    // Add events
    if (trip.events) {
      trip.events.forEach(event => {
        if (!event.startDateTime) return;
        // Events store times as UTC without timezone conversion
        let startDate = new Date(event.startDateTime);
        startDate.setHours(0, 0, 0, 0);

        let endDate = new Date(event.endDateTime || event.startDateTime);
        endDate.setHours(0, 0, 0, 0);
        const eventDurationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const key = getDateKey(startDate);
        if (!dateToItems[key]) dateToItems[key] = [];
        dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays: eventDurationDays });
      });
    }
  });

  // Add standalone flights
  const safeStandaloneFlights = standaloneFlights || [];
  safeStandaloneFlights.forEach(flight => {
    if (!flight.departureDateTime) return;
    // Convert UTC departure time to origin airport's local timezone
    let startDate = new Date(flight.departureDateTime);
    if (flight.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(flight.departureDateTime, flight.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    // Convert UTC arrival time to destination airport's local timezone
    let endDate = new Date(flight.arrivalDateTime || flight.departureDateTime);
    if (flight.destinationTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(flight.arrivalDateTime || flight.departureDateTime, flight.destinationTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'flight', data: flight, startDate, endDate, durationDays });
  });

  // Add standalone hotels
  const safeStandaloneHotels = standaloneHotels || [];
  safeStandaloneHotels.forEach(hotel => {
    if (!hotel.checkInDateTime) return;
    // Convert UTC check-in time to hotel's local timezone
    let startDate = new Date(hotel.checkInDateTime);
    if (hotel.timezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(hotel.checkInDateTime, hotel.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
    } else {
      startDate.setHours(0, 0, 0, 0);
    }
    // Convert UTC check-out time to hotel's local timezone
    let endDate = new Date(hotel.checkOutDateTime || hotel.checkInDateTime);
    if (hotel.timezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(hotel.checkOutDateTime || hotel.checkInDateTime, hotel.timezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
    } else {
      endDate.setHours(0, 0, 0, 0);
    }
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'hotel', data: hotel, startDate, endDate, durationDays });
  });

  // Add standalone transportation
  const safeStandaloneTransportation = standaloneTransportation || [];
  safeStandaloneTransportation.forEach(trans => {
    if (!trans.departureDateTime) return;
    let startDate = new Date(trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedDate = formatInTimezone(trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedDate.split('-').map(Number);
      startDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      startDate.setHours(0, 0, 0, 0);
    }

    let endDate = new Date(trans.arrivalDateTime || trans.departureDateTime);
    if (trans.originTimezone && typeof formatInTimezone === 'function') {
      const formattedEndDate = formatInTimezone(trans.arrivalDateTime || trans.departureDateTime, trans.originTimezone, 'YYYY-MM-DD');
      const [year, month, day] = formattedEndDate.split('-').map(Number);
      endDate = new Date(year, month - 1, day, 0, 0, 0, 0);
    } else {
      endDate.setHours(0, 0, 0, 0);
    }

    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'transportation', data: trans, startDate, endDate, durationDays });
  });

  // Add standalone car rentals
  const safeStandaloneCarRentals = standaloneCarRentals || [];
  safeStandaloneCarRentals.forEach(carRental => {
    if (!carRental.pickupDateTime) return;
    const startDate = new Date(carRental.pickupDateTime);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(carRental.dropoffDateTime || carRental.pickupDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'carRental', data: carRental, startDate, endDate, durationDays });
  });

  // Add standalone events
  const safeStandaloneEvents = standaloneEvents || [];
  safeStandaloneEvents.forEach(event => {
    if (!event.startDateTime) return;
    // Events store times as UTC without timezone conversion
    let startDate = new Date(event.startDateTime);
    startDate.setHours(0, 0, 0, 0);

    let endDate = new Date(event.endDateTime || event.startDateTime);
    endDate.setHours(0, 0, 0, 0);
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
    const key = getDateKey(startDate);
    if (!dateToItems[key]) dateToItems[key] = [];
    dateToItems[key].push({ type: 'event', data: event, startDate, endDate, durationDays });
  });

  // Helper function to get transportation icon
  function getTransportationIcon(method) {
    const iconMap = {
      'train': 'train',
      'bus': 'directions_bus',
      'ferry': 'directions_boat',
      'shuttle': 'airport_shuttle',
      'taxi': 'hail',
      'rideshare': 'hail',
      'taxi/rideshare': 'hail',
      'subway': 'directions_subway',
      'metro': 'directions_subway',
      'subway/metro': 'directions_subway',
      'tram': 'tram',
      'funicular': 'funicular',
      'gondola': 'gondola_lift',
      'monorail': 'monorail',
      'other': 'directions_run'
    };
    return iconMap[method?.toLowerCase()] || 'transportation';
  }

  // Generate 19 months of data with continuous flow (28 columns per row)
  // Each month's days flow sequentially, with rows breaking every 28 days
  const months = [];
  let currentDate = new Date(startMonth);

  while (currentDate < endMonth) {
    const monthYear = { month: currentDate.getMonth(), year: currentDate.getFullYear() };
    const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();

    const days = [];
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(currentDate.getFullYear(), currentDate.getMonth(), day, 0, 0, 0, 0);
      const key = getDateKey(dateObj);
      days.push({
        day: day,
        dateKey: key,
        items: dateToItems[key] || [],
        isToday: key === getDateKey(today),
        isInvalid: false
      });
    }

    months.push({
      month: monthYear.month,
      year: monthYear.year,
      name: monthNames[monthYear.month],
      days: days
    });

    currentDate.setMonth(currentDate.getMonth() + 1);
  }

  // Now reflow the days into 28-column rows (4 weeks × 7 days)
  // Each row contains exactly 28 days, aligned to Monday-Sunday weeks
  // Weeks are always Monday-Sunday, so add buffer days to align properly
  const reflowedMonths = [];
  let allDays = [];

  // Flatten all days from all months into a single array
  months.forEach(month => {
    month.days.forEach(day => {
      allDays.push({ ...day, originalMonth: month.month, originalYear: month.year });
    });
  });

  // Note: Buffer days are no longer needed since we're using month-based layout with fixed 31 columns
  // The old continuous flow logic has been replaced with month-specific rows

  // Pre-calculate global item row assignments based on overlaps
  const globalItemRowAssignments = {};
  const globalRowOccupancy = []; // Array of arrays tracking which items are in each row
  const processedItemIds = new Set(); // Track which items we've already processed

  // Sort all items by start date first
  const allItems = [];
  Object.keys(dateToItems).forEach(dateKey => {
    dateToItems[dateKey].forEach(item => {
      allItems.push(item);
    });
  });
  allItems.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

  // Remove duplicates (same item ID can appear multiple times in dateToItems)
  const uniqueItems = [];
  const seenIds = new Set();
  allItems.forEach(item => {
    if (!seenIds.has(item.data.id)) {
      seenIds.add(item.data.id);
      uniqueItems.push(item);
    }
  });

  // Assign each unique item to a global row number
  uniqueItems.forEach(item => {
    const itemId = item.data.id;

    // Normalize item dates for comparison
    const itemStart = normalizeDate(item.startDate).getTime();
    const itemEnd = normalizeDate(item.endDate).getTime();

    let assignedRow = -1;

    // Find first row where item doesn't overlap with anything
    for (let rowIdx = 0; rowIdx < globalRowOccupancy.length; rowIdx++) {
      let canFitInRow = true;
      // Check if item overlaps with any item in this row
      for (const otherItem of globalRowOccupancy[rowIdx]) {
        const otherStart = normalizeDate(otherItem.startDate).getTime();
        const otherEnd = normalizeDate(otherItem.endDate).getTime();
        // Items overlap if they share any days: NOT (end < otherStart OR start > otherEnd)
        const overlaps = !(itemEnd < otherStart || itemStart > otherEnd);

        if (overlaps) {
          canFitInRow = false;
          break;
        }
      }
      if (canFitInRow) {
        assignedRow = rowIdx;
        globalRowOccupancy[rowIdx].push(item);
        break;
      }
    }

    // Create new row if needed
    if (assignedRow === -1) {
      assignedRow = globalRowOccupancy.length;
      globalRowOccupancy.push([item]);
    }

    globalItemRowAssignments[itemId] = assignedRow;
  });


  // Group days into months, each with exactly 31 columns (31 days per month)
  // Blank boxes fill the end of months with fewer than 31 days
  let monthIndex = 0;

  while (monthIndex < months.length) {
    const monthData = months[monthIndex];
    const monthRowDays = [];

    // Add all days in this month
    monthData.days.forEach(day => {
      monthRowDays.push(day);
    });

    // Pad with blank days up to 31
    const daysInMonth = monthData.days.length;
    for (let i = daysInMonth; i < 31; i++) {
      monthRowDays.push({
        day: null,
        dateKey: null,
        items: [],
        isToday: false,
        isInvalid: true,
        isBlank: true
      });
    }

    reflowedMonths.push({
      month: monthData.month,
      year: monthData.year,
      name: monthData.name,
      days: monthRowDays
    });

    monthIndex++;
  }

%>

<div class="calendar-row-view h-full flex flex-col">
  <!-- Calendar grid - scrollable -->
  <div class="flex-1 overflow-auto">
    <div class="row-calendar-grid">
      <!-- Month rows -->
      <% reflowedMonths.forEach((monthData) => { %>
        <%
          // Calculate the number of item rows needed for this row
          // Get the date range for this row - find first and last valid dateKeys
          let heightRowStartDate = new Date();
          let heightRowEndDate = new Date();

          // Find the first valid dateKey
          for (let i = 0; i < monthData.days.length; i++) {
            if (monthData.days[i].dateKey) {
              const parts = monthData.days[i].dateKey.split('-').map(Number);
              heightRowStartDate = new Date(parts[0], parts[1] - 1, parts[2]);
              break;
            }
          }

          // Find the last valid dateKey
          for (let i = monthData.days.length - 1; i >= 0; i--) {
            if (monthData.days[i].dateKey) {
              const parts = monthData.days[i].dateKey.split('-').map(Number);
              heightRowEndDate = new Date(parts[0], parts[1] - 1, parts[2]);
              break;
            }
          }

          // Calculate month height based on max global row number that appears in this row
          let maxRowInMonth = -1;
          const itemsInThisRow = [];
          const seenItemIds = new Set();

          // Find all items that overlap with this row and get their global row assignments
          // IMPORTANT: Items are stored in dateToItems only at their START DATE
          // So we need to check ALL dateToItems keys, not just ones within the month row dates
          Object.keys(dateToItems).forEach(dateKey => {
            const items = dateToItems[dateKey] || [];
            items.forEach(item => {
              // Check if item overlaps with this row
              // Item overlaps if: item.end >= rowStart AND item.start <= rowEnd
              if (normalizeDate(item.endDate).getTime() >= normalizeDate(heightRowStartDate).getTime() && normalizeDate(item.startDate).getTime() <= normalizeDate(heightRowEndDate).getTime()) {
                const globalRow = globalItemRowAssignments[item.data.id];
                if (!seenItemIds.has(item.data.id)) {
                  seenItemIds.add(item.data.id);
                  itemsInThisRow.push({ id: item.data.id, globalRow });
                  if (globalRow > maxRowInMonth) {
                    maxRowInMonth = globalRow;
                  }
                }
              }
            });
          });


          // Calculate height: we need room for all rows up to maxRowInMonth
          const monthHeight = Math.max(2, 1.2 + (maxRowInMonth + 1) * 1.75);
        %>
        <div class="month-row-wrapper" style="min-height: <%= monthHeight %>rem;">
          <!-- Month label -->
          <div class="month-row-label">
            <div class="month-name"><%= monthData.name.substring(0, 3) %></div>
            <div class="year"><%= monthData.year %></div>
          </div>

          <!-- Days grid with items -->
          <div class="days-row-grid">
            <!-- Multi-day items layer -->
            <div class="row-multi-day-layer">
              <%
                // Collect items that overlap with this row's date range
                const monthItems = [];
                const rowItemIds = new Set();

                // Get the date range for this row - find first and last valid dateKeys
                let rowStartDate = new Date();
                let rowEndDate = new Date();

                // Find the first valid dateKey
                for (let i = 0; i < monthData.days.length; i++) {
                  if (monthData.days[i].dateKey) {
                    const parts = monthData.days[i].dateKey.split('-').map(Number);
                    rowStartDate = new Date(parts[0], parts[1] - 1, parts[2]);
                    break;
                  }
                }

                // Find the last valid dateKey
                for (let i = monthData.days.length - 1; i >= 0; i--) {
                  if (monthData.days[i].dateKey) {
                    const parts = monthData.days[i].dateKey.split('-').map(Number);
                    rowEndDate = new Date(parts[0], parts[1] - 1, parts[2]);
                    break;
                  }
                }

                // Iterate through all dateToItems to find items that overlap with this row
                Object.keys(dateToItems).forEach(dateKey => {
                  const items = dateToItems[dateKey] || [];
                  items.forEach(item => {
                    const itemId = item.data.id;

                    // Check if item overlaps with this row and hasn't been added yet
                    if (normalizeDate(item.endDate).getTime() >= normalizeDate(rowStartDate).getTime() && normalizeDate(item.startDate).getTime() <= normalizeDate(rowEndDate).getTime() && !rowItemIds.has(itemId)) {
                      rowItemIds.add(itemId);
                      monthItems.push({ item, itemId });
                    }
                  });
                });

                // Sort items by start date ascending
                monthItems.sort((a, b) => {
                  const dateA = a.item.startDate;
                  const dateB = b.item.startDate;
                  return dateA.getTime() - dateB.getTime();
                });

                // Use pre-calculated global row assignments and calculate column positions
                monthItems.forEach((itemData) => {
                  // Find the position of this item in the row's day array
                  const itemStartDate = itemData.item.startDate;
                  const itemEndDate = itemData.item.endDate;
                  let startCol = -1;
                  let endCol = -1;

                  // Find the first day this item appears in this row
                  for (let i = 0; i < monthData.days.length; i++) {
                    if (monthData.days[i].dateKey) {
                      const dayDate = new Date(monthData.days[i].dateKey.split('-').map(Number)[0],
                                              monthData.days[i].dateKey.split('-').map(Number)[1] - 1,
                                              monthData.days[i].dateKey.split('-').map(Number)[2]);

                      if (normalizeDate(dayDate).getTime() >= normalizeDate(itemStartDate).getTime()) {
                        startCol = i;
                        break;
                      }
                    }
                  }

                  // Find the last day this item appears in this row
                  for (let i = monthData.days.length - 1; i >= 0; i--) {
                    if (monthData.days[i].dateKey) {
                      const dayDate = new Date(monthData.days[i].dateKey.split('-').map(Number)[0],
                                              monthData.days[i].dateKey.split('-').map(Number)[1] - 1,
                                              monthData.days[i].dateKey.split('-').map(Number)[2]);

                      if (normalizeDate(dayDate).getTime() <= normalizeDate(itemEndDate).getTime()) {
                        endCol = i;
                        break;
                      }
                    }
                  }

                  // Skip if item doesn't actually appear in this row (shouldn't happen but be safe)
                  if (startCol === -1 || endCol === -1) {
                    return;
                  }

                  const daysSpanned = endCol - startCol + 1;
                  const assignedRow = globalItemRowAssignments[itemData.itemId];

                  // Store calculated values for rendering
                  itemData.rowInMonth = (assignedRow !== undefined) ? assignedRow : 0;
                  itemData.daysSpanned = daysSpanned;
                  itemData.startCol = startCol;

                });
              %>
              <% monthItems.forEach((itemData) => { %>
                <%
                  const { item, itemId, rowInMonth, daysSpanned, startCol } = itemData;
                  const itemType = item.type;
                  const itemColor = getItemHexColor(itemType);
                %>
                <% if (itemType === 'trip') { %>
                  <% const tripColor = item.data.purpose === 'business' ? getItemHexColor('business') : getItemHexColor('trip'); %>
                  <div class="row-multi-day-bar calendar-item <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %>" data-item-id="<%= itemId %>" data-item-type="trip" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= tripColor %>33; color: <%= tripColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= tripColor %>;">luggage</span>
                    <span class="truncate"><%= item.data.name %></span>
                  </div>
                <% } else if (itemType === 'flight') { %>
                  <%
                    const originCode = item.data.origin ? item.data.origin.substring(0, 3).toUpperCase() : '';
                    const destCode = item.data.destination ? item.data.destination.substring(0, 3).toUpperCase() : '';
                  %>
                  <div class="row-multi-day-bar flight-bar-row calendar-item" data-item-id="<%= itemId %>" data-item-type="flight" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <div class="flight-codes-row">
                      <div><%= originCode %></div>
                      <div><%= destCode %></div>
                    </div>
                  </div>
                <% } else if (itemType === 'hotel') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="hotel" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">hotel</span>
                    <span class="truncate"><%= item.data.hotelName %></span>
                  </div>
                <% } else if (itemType === 'event') { %>
                  <div class="row-multi-day-bar <% if (!item.data.isConfirmed) { %>calendar-item-tentative<% } %> calendar-item" data-item-id="<%= itemId %>" data-item-type="event" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">event</span>
                    <span class="truncate"><%= item.data.name %></span>
                  </div>
                <% } else if (itemType === 'transportation') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="transportation" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;"><%= getTransportationIcon(item.data.method) %></span>
                    <span class="truncate"><%= item.data.origin %> → <%= item.data.destination %></span>
                  </div>
                <% } else if (itemType === 'carRental') { %>
                  <div class="row-multi-day-bar calendar-item" data-item-id="<%= itemId %>" data-item-type="carRental" data-col="<%= startCol %>" data-span="<%= daysSpanned %>" style="--day-idx: <%= startCol %>; --span: <%= daysSpanned %>; --row-in-month: <%= rowInMonth %>; background-color: <%= itemColor %>33; color: <%= itemColor %>;">
                    <span class="material-symbols-outlined" style="font-size: 14px; flex-shrink: 0; color: <%= itemColor %>;">directions_car</span>
                    <span class="truncate"><%= item.data.company %></span>
                  </div>
                <% } %>
              <% }) %>
            </div>

            <!-- Day cells -->
            <% monthData.days.forEach((dayData, dayIdx) => { %>
              <%
                const isBlankDay = dayData.isBlank;
                const hasItems = dayData.items && dayData.items.length > 0;
                let isWeekend = false;
                let isBufferDay = false;

                if (!isBlankDay && dayData.dateKey) {
                  // Weekend detection based on actual day of week from the date
                  const dayDate = new Date(dayData.dateKey.split('-').map(Number)[0],
                                          dayData.dateKey.split('-').map(Number)[1] - 1,
                                          dayData.dateKey.split('-').map(Number)[2]);
                  // getDay: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
                  // We want: Saturday (6) and Sunday (0) to be weekends
                  const dayOfWeek = dayDate.getDay();
                  isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // Sunday and Saturday
                  isBufferDay = dayData.isBufferDay || dayData.isInvalid;
                }
              %>
              <div class="row-day-cell <% if (isBlankDay) { %>blank-day<% } %> <% if (isBufferDay) { %>buffer-day<% } %> <% if (dayData.isToday) { %>today<% } %> <% if (hasItems) { %>has-items<% } %> <% if (isWeekend) { %>weekend<% } %>" id="<% if (dayData.dateKey) { %>date-<%= dayData.dateKey %><% } %>" data-date="<%= dayData.dateKey %>">
                <% if (!isBlankDay && !isBufferDay && dayData.day) { %>
                  <div class="day-number"><%= dayData.day %></div>
                <% } %>
              </div>
            <% }) %>
          </div>
        </div>
      <% }) %>
    </div>
  </div>
</div>

<style>
  .calendar-row-view {
    display: flex;
    flex-direction: column;
  }

  .row-calendar-grid {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .month-row-wrapper {
    display: flex;
    gap: 0;
    align-items: stretch;
    border-left: 2px solid #e5e7eb;
    position: relative;
  }

  .month-row-label {
    width: 50px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: #6b7280;
    background: #f9fafb;
    padding: 0.5rem 0.25rem;
    flex-shrink: 0;
    text-align: center;
    border-right: 2px solid #e5e7eb;
  }

  .month-row-label .month-name {
    font-weight: 700;
  }

  .month-row-label .year {
    font-size: 0.65rem;
    color: #9ca3af;
  }

  .days-row-grid {
    display: grid;
    grid-template-columns: repeat(31, minmax(24px, 1fr));
    gap: 0;
    flex: 1;
    position: relative;
  }

  .row-multi-day-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  .row-multi-day-bar {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.5rem;
    pointer-events: auto;
    top: calc(1.2rem + var(--row-in-month) * 1.75rem);
    left: calc(var(--day-idx) * calc(100% / 31) + 1px);
    width: calc(var(--span) * calc(100% / 31) - 2px);
  }

  /* Calendar item styling */
  .calendar-item {
    cursor: pointer;
  }

  .calendar-item:hover {
    opacity: 0.85;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  /* Flight bar row view - centered two-line airport codes */
  .row-multi-day-bar.flight-bar-row {
    padding: 0;
    gap: 0;
    justify-content: center;
  }

  .flight-codes-row {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    gap: 0;
    font-weight: bold;
    font-size: 0.65rem;
    line-height: 1;
  }

  .calendar-item-tentative::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.1) 2px,
      rgba(0, 0, 0, 0.1) 4px
    );
    pointer-events: none;
    border-radius: 0.25rem;
  }

  .row-day-cell {
    border-right: 1px solid rgba(229, 231, 235, 0.4);
    border-bottom: none;
    padding: 0;
    overflow: visible;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    min-height: 32px;
    background: white;
    transition: background-color 0.2s;
  }

  .row-day-cell:hover {
    background-color: #f9fafb;
  }

  .row-day-cell.weekend {
    background-color: #fafafa;
  }

  .row-day-cell.weekend:hover {
    background-color: #f5f5f5;
  }

  .row-day-cell.today {
    background-color: #eff6ff;
    border-right-color: #3b82f6;
  }

  .row-day-cell.today .day-number {
    color: #3b82f6;
    font-weight: 600;
  }

  .row-day-cell.invalid-day {
    background-color: #f3f4f6;
    cursor: not-allowed;
    border-right-color: rgba(209, 213, 219, 0.4);
  }

  .row-day-cell.invalid-day:hover {
    background-color: #f3f4f6;
  }

  .day-number {
    font-size: 0.7rem;
    font-weight: 500;
    color: #374151;
    padding: 0.25rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 5;
  }

  .row-day-cell.has-items {
    padding-top: 0;
  }

  .row-day-cell.blank-day {
    background-color: #f3f4f6;
    cursor: default;
  }

  .row-day-cell.blank-day:hover {
    background-color: #f3f4f6;
  }
</style>

<script>
  function scrollYearViewToday() {
    const todayCell = document.querySelector('.row-day-cell.today');
    if (todayCell) {
      todayCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  window.scrollYearViewToday = scrollYearViewToday;
</script>
